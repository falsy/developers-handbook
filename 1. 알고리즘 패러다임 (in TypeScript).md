# Algorithm Paradigm in TypeScript

기본적인 몇가지 알고리즘 패러다임을 타입스크립트를 사용한 간단한 구현과 함께 알아봅니다.

이 글은 깊은 이해보다 기본적인 메커니즘을 이해하는 목적으로 작성되었기 때문에 전문적인 지식선에서 보기엔 잘못된 설명이 있을 수 있습니다. 또한 구현된 코드 역시 이해를 위한 단순한 구현 코드입니다.

글에 잘못된 부분이 있다면 이슈나 풀 리퀘스트 부탁드립니다. 🙇‍♂️

## Reference

이 문서는 [신찬수 교수님](https://www.youtube.com/@ChanSuShin)의 유튜브 강의와 추가로 공부한 내용을 함께 정리한 것입니다.

## List

- [분할 정복(Divide and conquer)](분할-정복divide-and-conquer)
- [탐욕(greedy)](탐욕greedy)
- 동적 계획(DP, Dynamic Programming)
- 퇴각 검색(Backtracking)
- 최단 경로(Shortest Path)
  - 벨먼-포드(Bellman-Ford)
  - 데이크스트라(Dijkstra)
- 최소 신장 트리(MST, Minimum Spanning Tree)

## 분할 정복(Divide and conquer)

분할 정복은 큰 문제를 더 작은 독립적인 하위 문제로 나누고 각 하위 문제를 해결한 다음 이 해결된 결과를 결합하여 원래의 큰 문제를 해결하는 방식을 이야기합니다. 이 방법은 주로 재귀를 통해 구현합니다.

예를들여 $a^n$을 구하는 문제가 있을 때, 일반적으로 재귀를 통해 구현한다고 하면

```ts
// a = 밑, n = 지수
const power = (a: number, n: number) => {
  if (n === 1) return a
  return a * power(a, n - 1)
}
```

위와 같이 구할 수 있는데요. 이렇게 구현을 하면 power가 $n$번 호출되어 시간 복잡도가 $O(n)$이 됩니다.
하지만 분할 정복방법을 사용하면 아래와 같이 구현할 수 있는데요.

```ts
const power = (a: number, n: number) => {
  if (n === 0) return 1
  const half = power(a, Math.floor(n / 2))

  if (n % 2 === 0) {
    return half * half
  } else {
    return half * half * a
  }
}
```

위와 같이 재귀 호출로 $a^(n/2)$ 를 계산해서 half에 저장 후 사용하여 수행 시간을 단축할 수 있습니다. 위와 같이 구현할 경우 시간 복잡도는 $O(\log n)$이 됩니다.

[⬆목차](#list)

## 탐욕(greedy)

문제를 해결하는데 있어서 각 단계에서 가장 최선의 선택을 하는 직관적이고 이해하기 쉬운 방법입니다. 지역적으로 최선의 선택을 하여 전역적으로 최선의 해를 찾으려는 방법입니다.

#### Note.

> 하지만 개인적인 생각으론 문제 해결의 근사한 값을 구한다고 하면 쉬운 방법이라 생각하지만, 이야기한 그 '최선의 선택'을 생각해 내는 것이 쉽지 않은 거 같아요.

가장 간단한 예시로는 동전 교환 문제가 있습니다.
예를 들어서 동전이 1, 10, 50, 100, 500 단위로 있을때, 주어진 금액에 대한 최소한의 동전수의 응답을 구한다고 하면,

```ts
const coinChange = (amount: number): number => {
  const coins = [1, 10, 50, 100, 500]
  coins.sort((a, b) => b - a)

  let remainingAmount = amount
  let count = 0

  for (const coin of coins) {
    while (remainingAmount >= coin) {
      remainingAmount -= coin
      count += 1
    }
  }

  return count
}
```

주의할 점은, 주어진 각각의 동전 단위가 2배 이상으로 커야 합니다. 예를 들어 동전의 단위가 1, 10, 50, 70, 100 이라면 50원과 70원이 2배 이상 크지 않기 때문에 그리디 방법으로는 근사한 값을 응답하지만, 확실한 답을 응답하지 않을 수 있습니다.

다음으로 강의실 배정 문제로, 하나의 강의실과 강의의 시작 시간과 종료 시간이 목록이 주어졌을 때, 주어진 시간에 가장 많은 강의를 선택하는 문제인데요. 구현은 어렵지 않기 때문에, 최선의 선택은 "강의 종료 시간이 빠른 강의부터" 선택하는 방법입니다.

그리고 또 하나의 대표적인 탐욕법의 예로 허프만 코딩(Huffman coding)이 있습니다.
허프만 코딩은 정보 압축 알고리즘 중에 하나로, 주어진 데이터에 자주 사용되는 문자에 적은 공간을 부여해서 전체의 데이터 길이를 줄이는 방법입니다.

간단하게 설명이 어려워서.. 간단한 예로, A(12), B(6), C(5), D(4), E(3) 이렇게 주어졌을때(괄호 안의 숫자는 빈도수),
빈도수를 기준으로 오름차순으로 정렬한 후 빈도수가 작은 값부터 두 개씩 합치며 힙 트리를 만들어 구성합니다.

```
E(3), D(4), C(5), B(6), A(12)

// Heap Tree

   E(3)    D(4)    C(5)    B(6)    A(12)
```

위와 같이 시작해서 우선, 가장 작은 E와 D를 합치고 배열에는 합쳐진 ED로 빈도수는 3 + 4로 7이 됩니다. 그리고 E와 D는 Min Heap에 추가합니다.

```
C(5), B(6), ED(7), A(12)

// Heap Tree

      ED(7)
    ┌───┴───┐
   E(3)    D(4)    C(5)    B(6)    A(12)
```

그리고 다시 작은 빈도수의 두개를 합쳐 줍니다.

```
ED(7), CB(11), A(12)

// Heap Tree

      ED(7)           CB(11)
    ┌───┴───┐       ┌───┴───┐
   E(3)    D(4)    C(5)    B(6)    A(12)
```

동일하게 계속 진행하면,

```
EDCB(18), A(12)

// Heap Tree

             EDCB(18)
        ┌───────┴───────┐
      ED(7)           CB(11)
    ┌───┴───┐       ┌───┴───┐
   E(3)    D(4)    C(5)    B(6)    A(12)
```

```
EDCBA(30)

// Heap Tree
                     EDCBA(30)
                ┌───────┴───────┐
              EDCB(18)          A(12)
        ┌───────┴───────┐
      ED(7)           CB(11)
    ┌───┴───┐       ┌───┴───┐
   E(3)    D(4)    C(5)    B(6)
```

이렇게 최종적으로 만들어진 트리를 루트 노드를 기준으로 경로에 따라 1과 0을 할당함으로 각 문자에 빈도수에 따른 공간을 할당할 수 있습니다.

```
// Heap Tree
                     EDCBA(30)
              1 ┌───────┴───────┐ 0
              EDCB(18)          A(12)
      1 ┌───────┴───────┐ 0
      ED(7)           CB(11)
  1 ┌───┴───┐ 0   1 ┌───┴───┐ 0
   E(3)    D(4)    C(5)    B(6)
```

```
A = 0
B = 100
C = 101
D = 110
E = 111
```

[⬆목차](#list)
