# 운영체제

`운영체제(OS: Operating System)`는 컴퓨터 하드웨어와 소프트웨어를 관리하고, 사용자와 컴퓨터 간의 인터페이스를 제공하는 시스템 소프트웨어입니다. 운영체제는 크게 프로세스 관리, 메모리 관리, 저장장치 관리, 입출력 관리, 보안 및 권한 관리, 사용자 인터페이스 제공 등의 역할을 수행합니다.

## 목차

- [1. 프로세스(process)](#1-프로세스process)
- [2. 스레드(thread)](#2-스레드thread)
- [3. CPU 스케줄링](#3-cpu-스케줄링)
- [4. 동기화](#4-동기화)
- [5. 교착 상태(Deadlock)](#5-교착-상태deadlock)
- [6. 메모리 관리](#6-메모리-관리)
- [7. 파일 시스템](#7-파일-시스템)

## 1. 프로세스(process)

프로세스는 컴퓨터에서 실행 중인 프로그램을 말하며, 단순히 보조 기억 장치에 저장된 프로그램 파일과 달리 프로세스는 메모리에 로드되어 CPU의 실행을 받는 동적인 실행 단위입니다.

프로세스는 실행 중인 프로그램의 인스턴스로 서로 독립적으로 동작하며 각 프로세스는 고유한 메모리 공간을 가지고 있습니다. 그리고 생성과 준비, 실행, 대기, 종료와 같은 상태를 가지고 있으며 프로세스는 실행을 위해서 CPU 시간, 메모리, 파일 및 입출력 장치와 같은 시스템 자원(resource)를 할당받습니다. 또한 현대 운영체제는 여러 프로세스를 동시 실행(멀티 태스킹)을 지원하며 이는 운영체제의 스케줄러가 CPU의 시간을 분배하여 가능하게 합니다.

### - 프로세스의 구조

프로세스는 다음과 같이 크게 네 가지의 메모리 영역으로 구분됩니다.

#### 1. 코드 영역(Text Section)

실행할 프로그램의 코드가 저장되며, 일반적으로 읽기 전용으로 설정됩니다.

#### 2. 데이터 영역(Data Section)

전역 번수와 정적 변수가 저장됩니다.

#### 3. 힙 영역(Heap)

동적으로 할당된 메모리가 저장되며, 크기가 유동적이고 프로그램 실행 중 변경될 수 있습니다.

#### 4. 스택 영역(Stack)

함수 호출과 관련된 지역 변수, 매개변수, 리턴 주소가 저장되며 함수가 호출될 때 크기가 동적으로 변합니다.

#### 정적 영역과, 동적 영역

> 코드 영역과 데이터 영역은 정적 영역으로 메모리의 크기가 고정되어 있으며 힙 영역과 스택 영역은 동적 영역으로 충돌을 피하기 위해 일반적으로 힙 영역은 낮은 메모리 주소에서 높은 주소로 크기를 갖고 스택 영역은 높은 주소에서 낮은 주소로 크기를 갖습니다.

> 스택 영역은 크기가 동적으로 변할 수 있지만 프로그램이 컴파일 단계에서 사용할 수 있는 메모리의 크기가 정해지기 때문에 `정적 할당 영역`이라고 하기도 합니다.

### - 프로세스 제어 블록(PCB: Process Control Block)

운영체제는 PCB라는 데이터 구조를 사용하여 프로세스를 관리하며 PCB는 다음과 같은 정보를 포함합니다.

#### 1. 프로세스 ID(PID)

각 프로세스를 구분하는 고유한 식별자.

#### 2 .프로세스 상태

준비, 실행, 대기 등의 상태.

#### 3. CPU 레지스터 정보

프로세스 실행 시 필요한 레지스터 값.

> 운영체제는 멀티태스킹을 위하여 각 프로세스의 CPU의 시간 나누어 실행합니다.(스케줄링) 이때 각 프로세스가 자신의 실행 차례가 돌아왔을 때 작업을 이어할 수 있도록 이전의 CPU 레지스터 값, 프로그램 카운터\*, 스택 포인터 등 `프로세스 상태(실행 상태)`를 가지고 있습니다.

> 이때, 이전의 프로세스의 실행 상태 전체를 문맥(context)이라고 하며 위와 같이 중간 정보를 기억하고 다음에 실행할 프로레스의 상태를 복원, 그리고 스케줄러가 CPU를 다른 프로세스에 할당하는 과정을 `문맥 전환(context switch)`이라 합니다.

#### 프로그램 카운터\*

> 다음에 실행될 명령어의 주소를 가지고 있습니다.

#### 4. 메모리 관리 정보

프로세스의 메모리 할당 정보(코드, 데이터, 힙, 스택 영역 등)

#### 5. 입출력 상태 정보

열링 파일, 사용 중인 장치 정보.

#### 6. 스케줄링 정보

프로세스 우선순위, 스케줄링 큐 상태.

[⬆목차](#목차)

## 2. 스레드(thread)

스레드는 프로세스 내에서 실행되는 작업의 단위를 이야기하며, 하나의 프로세스에는 하나 이상의 스레드가 있을 수 있습니다. 같은 프로세스 내의 스레드는 메모리 공간과 시스템 자원을 공유하면서 독립적으로 실행됩니다.

### - 자원 공유

같은 프로세스의 스레드는 개별적인 스택과 CPU 레지스터를 가지지만 코드, 데이터, 힙 메모리를 공유합니다.

> 스레드는 스레드 ID, 프로그램 카운터를 비롯한 레지스터, 스택 등으로 실행에 필요한 최소한의 정보만을 가지고 있습니다.

### - 경량성

스레드는 프로세스보다 가볍고 생성/소멸 비용이 낮습니다. 그리고 스레드 간의 `문맥 전환(context switch)` 비용이 프로세스 간 전환보다 적습니다.

### - 멀티스레딩

하나의 프로세스내에서 여러 스레드가 병렬로 실행할 수 있습니다. 그리고 이는 멀티 코어 CPU 환경에서 여러 스레드가 병렬로 실행되어 성능이 향상되고 UI 프로그램에서 멀티스레딩을 사용하면 긴 작업이 진행되는 동안에도 사용자 인터페이스가 응답성을 유지할 수 있으며 같은 프로세스의 자원을 스레드가 공유하기 때문에 `프로세스 간 통신(IPC)` 보다 간단하고 빠릅니다.

하지만 자원을 공유하기 때문에 스레드가 공유 자원을 접근 시 데이터 충돌이나 데드락 같은 동기화 문제가 발생할 수 있으며, 병렬 실행으로 인해 문제 발생시 디버깅이 어려울 수 있습니다.

#### 작업 단위

> 초기의 운영체제와 CPU에서는 작업을 프로세스 단위로 처리하였지만, 현대의 운영체제는 작업을 스레드 단위로 CPU에 전달하는 것이 일반적입니다. 이는 앞서 이야기 한 내용과 같이 프로세스의 문맥 전환 비용이 높아 효율적인 멀티태스킹에 제약이 있으며, 멀티코어 CPU 환경에서 각 코어는 독립적인 스테드를 실행할 수 있기 때문에 스레드 단위로 작업을 배분하면 CPU 자원을 더 효과적으로 활용할 수 있기 때문입니다.

[⬆목차](#목차)

## 3. CPU 스케줄링

CPU 스케줄링은 운영체제가 CPU 자원을 효과적으로 사용하기 위해, 준비 상태에 있는 프로세스나 스레드 중 하나를 선택해서 CPU에게 할당하는 과정을 의미합니다.

CPU 스케줄링에는 `선점형 스케줄링`과 `비선점형 스케줄링`이 있으며 선점형 스케줄링은 반응이 짧고 사용자 중심 작업에 적합하며 긴 작업이 짧은 작업을 계속 지연시키는 것을 방지하지만, 문맥 전환 비용이 발생합니다. 반대로 비선점형 스케줄링은 문맥 전환 비용이 적지만 긴 작업이 계속 짧은 작업을 지연시키는 문제가 발생할 수 있습니다.

모든 프로세스는 각각의 `PCB(Process Control Block)`에 우선순위가 포함될 수 있으며, 스케줄링 큐는 대표적으로 `준비 큐`와 `대기 큐`로 구성됩니다. 입출력을 요청한 프로세스는 대기 상태로 전환되어 대기 큐에 추가되며, 입출력 작업이 완료되면 인터럽트가 발생하여 해당 프로세스의 상태를 준비 상태로 변경하고 준비 큐로 이동시킵니다.

준비 큐에 있는 프로세스들은 스케줄링 알고리즘에 따라 CPU에 할당됩니다. 선점형 스케줄링의 경우, 타이머 인터럽트에 의해 실행 시간이 완료되면 현재 실행 중인 프로세스는 준비 큐로 이동하고, 디스패처가 다음 프로세스를 선택하여 CPU를 할당합니다.

### - 스케줄링 알고리즘

#### 1. 선입 선처리 스케줄링(FCFS: First Come First Serve)

비선점 스케줄링으로 요청 순서대로 프로세스를 처리하는 알고리즘으로 단순하고 구현이 쉽지만 긴 작업이 먼저 들어오면 짧은 작업이 대기해야하는 Convoy Effect가 발생할 수 있습니다.

#### 2. 최단 작업 우선 스케줄링(SJF: Shortest Job First)

실행 시간이 가장 짧은 작업을 먼저 처리하는 알고리즘으로 평균 대기시간을 최소화 하지만, 실행 시간을 정확하게 예측하기 어렵고 긴 작업은 계속 지연될 수 있습니다.

#### 3. 라운드 로빈 스케줄링(Round Robin)

프로세스들 사이에 우선순위를 두지 않고, 순서대로 각 프로세스에 일정한 사이클 시간(Time Quantum)을 할당하고 이를 초과하면 다음 프로세스로 전환하는 스케줄링 방식으로 모든 프로세스가 공평하게 CPU를 사용하지만 적절한 사이클 시간(Time Quantum)이 중요합니다. 너무 크면 FCFS 처럼 동작하며 너무 작으면 문맥 전환 비용이 증가합니다.

#### 4. 최소 잔여 시간 우선 스케줄링(SRT: Shortest Remaining Time)

라운드 로빈 스케줄링과 최단 작업 우선 스케줄링이 결합된 형태로, 라운드 로빈 스케줄링과 같이 정해진 일정한 사이클 시간(Time Quantum)을 할당하고 초과하면 다음 프로세스로 실행 시간이 가장 짧은 작업을 선택하는 방법입니다.

#### 5. 우선순위 스케줄링(Priority Scheduling)

프로세스마다 우선순위를 설정하고 우선순위가 높은 작업부터 처리하며 중요한 작업을 빨리 처리할 수 있지만, 우선순위가 낮은 작업이 무기한 대기 상태에 빠질 수 있는 Starvation(기아) 문제가 발생할 수 있습니다. 그리고 이 문제를 해결하기 위해 aging 기법이 있으며, aging 기법은 오랫동안 대기한 프로세스에 우선순위를 점차 높이는 방법입니다.

#### 6. 다단계 큐 스케줄링(Multilevel Queue Scheduling)

프로세스를 우선순위에 따라 서로 다른 큐에 배치하고, 각 큐에 별도의 스케줄링 알고리즘을 적용하는 방법입니다. 다양한 프로세스 유형에 맞춘 처리가 가능하지만 각 큐의 우선순위를 설정하는 것이 어렵고 큐 간의 이동이 불가능하여 Starvation 문제가 발생할 수 있습니다.

#### 7. 다단계 피드백 큐(Multilevel Feedback Queue)

프로세스가 실행 중인 큐에서 더 높은 우선순위나 낮은 우선순위의 큐로 이동할 수 있는 알고리즘으로 동적인 우선순위 조정이 가능한 알고리즘입니다. 준비 상태의 높은 우선순위로 CPU에 할당되며 정해진 CPU 시간안에 동작이 완료되지 않으면 점차 우선순위를 낮추어 상대적으로 CPU 사용 시간이 짧은 프로세스가 높은 우선순위로 동작할 수 있게 되는 방식입니다. 또한 Starvation 문제에 대해 aging 기법으로 낲은 우선순위에서 오랜시간 대기한 프로세스는 우선순위를 점차 높여 보완합니다.

[⬆목차](#목차)

## 4. 동기화

다중 프로세스나 다중 스레드 환경에서 여러 작업이 동시에 실행되면서 `공유 자원*`이나 `임계 구역*`에 접근할 때 데이터 충돌이나 일관성 문제 등 `경쟁 상태(Race Condition)`가 발생할 수 있습니다. 그리고 이를 위해 프로세스나 스레드 간의 공유 자원에 대한 접근 순서를 제어하고 올바른 실행 결과를 보장하기 위한 기술이 동기화 입니다.

#### 공유 자원\*

> 프로세스나 스레드가 공유하는 자원을 말하며 전역 변수, 파일, 입출력장치, 보조기억장치 등을 말합니다.

#### 임계 구역\*

> 프로세스나 스레드가 공유 자원에 접근하는 코드 영역을 말합니다.

`경쟁 상태(Race Condition)`란 여러 프로세스나 스레드가 동시에 공유 자원에 접근하면 실행 순서에 따라 결과가 달라질 수 있으며 예를 들어 은행 계좌에서 두 스레드가 동시에 출금 하면 잔고가 음수가 될 수 있습니다. 또한, 공유 데이터를 동시에 수정하면 데이터가 손실이 발생할 수 있는데, 예를 들어 두 스레드가 리스트에 동시에 값을 삽입하면 하나의 값이 손실될 수 있습니다.

위와 같은 문제를 막기 위해 동기화에는 프로세스나 스레드를 올바른 순서로 실행하는 `실행 순서 제어` 방법과 여러 프로세스나 스레드가 동시에 공유 자원에 접근하지 못하도록 보호하는 `상호 배제` 방법이 사용됩니다.

### - 임계 구역 문제 해결 조건

임계 구역 문제의 해결을 위해서는 세 가지 조건을 만족해야하며 그 조건은 아래와 같습니다.

#### 1. 상호 배제

한 번에 하나의 프로세스 또한 스레드만 임계 구역을 실행할 수 있어야 합니다.

#### 2. 진행

임계 구역에 접근하는 프로세스가 없을 때, 임계 구역에 진입할 프로세스를 결정하는 과정이 무기한 지연되지 않아야 합니다.  
(임계 구역에 접근하는 프로세스가 없을때, 프로세스는 임계 구역에 진입할 수 있어야 한다.)

#### 3. 유한 대기

한 프로세스가 임계 구역에 진입하려고 대기하는 동안, 다른 프로세스가 무한히 임계 구역에 진입하는 일이 없어야 합니다.  
(프로세스가 임계 구역에 진입하기 위해 무한이 대기하는 일이 없어야 한다.)

### - 동기화 기법(도구)

동기화를 위해 여러 프로세스나 스레드가 동시에 자원에 접근하지 못하도록 보호하는(상호 배제) 방법의 도구로 대표적인 몇가지는 아래와 같습니다.

#### 1. 뮤텍스(Mutex, Mutual Exclusion)

하나의 프로세스 또는 스레드만 접근할 수 있도록 잠금(lock)을 제공하는 방법으로 파일 쓰기나 리스트 삽입 등에 사용되며 단점으로는 `교착 상태(Deadlock)`가 발생할 수 있습니다.

#### 2. 세마포어(Semaphore)

뮤텍스와 비슷하지만 동시의 N개의 프로세스나 스레드가 자원에 접근할 수 있도록 허용할 때 사용하며, 세부적으로는 이진 세마포어와 카운팅 세마포어가 있으며 카운팅 세마포어는 0개 이상의 프로세스나 스레드의 접근을 허용하며 이진 세마포어는 0 또는 1의 값만을 가지고 뮤텍스처럼 동작합니다. 단점으로는 세마포어를 잘못 사용할 경우 데드락이나 자원 누수가 발생할 수 있습니다.

#### 뮤텍스와 이젠 세마포어의 차이

> 이진 세마포어는 소유권이 없어서 잠금을 설정한 스레드가 아닌 다른 스레드도 잠금을 해지할 수 있지만 뮤텍스는 소유권 개념이 있어서 잠금을 건 스레드만 잠금을 해지할 수 있습니다. 그리고 설계 목적에서도 차이가 있는데, 무텍스는 주로 임계 구역 보호를 위해 설계되었으며 이진 세마포어는 상호 배제 뿐 아니라 신호 전달 처리도 할 수 있습니다. 예를 들면 한 프로세스가 데이터를 준비한 후 다른 프로세스에게 작업을 시작하라는 신호를 보낼 수 있습니다.(프로세스 간 순서 제어)

#### 3. 모니터

뮤턴스와 조건 변수를 조립한 고수준의 동기화 도구로 자원 접근과 조건 처리를 한곳에서 관리합니다.

[⬆목차](#목차)

## 5. 교착 상태(Deadlock)

두개 이상의 프로세스 또는 스레드가 서로가 가지고 있는 자원을 기다리며 무한 대기 상태에 빠지는 상황을 말합니다.

### - 교착 상태 발생 조건

교착 상태는 아래의 네 가지 조건을 동시에 만족할 때 발생합니다.

#### 1. 상호 배제(Mutual Exclusion)

자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다.

#### 2. 점유와 대기(Hold and Wait)

프로세스가 최소 하나의 자원을 점유한 상태에서, 추가로 다른 자원을 요청하며 대기 상태에 있어야 합니다.

#### 3. 비선점(No Preemption)

프로세스가 점유하고 있는 자원을 다른 자원은 강제로 빼앗을 수 없고, 프로세스가 작업이 끝나야만 자원을 반활할 수 있어야 합니다.

#### 4. 환형 대기(Circular Wait)

두 개 이상의 프로세스가 자원을 점유한 채, 서로 다른 프로세스가 가진 자원을 기다리는 상태가 원형으로 연결되어야 합니다.

### - 교착 상태 예방

교착 상태 발생 조건의 네 가지 중 한가지라도 충족되지 않도록 하는 하여 예방할 수 있지만, 상호 배제의 경우 자원을 모든 프로세스에서 사용할 수 있도록 하는 것은 이론적으로는 가능하지만 실질적으로는 어려운 조건이고 점유와 대기의 경우 필요로 하는 자원을 모두 점유할 수 있을 때까지 자원을 점유하지 않는 것으로 가능은 하지만 효율적으로 작업을 수행할 수 없는 문제가 있습니다.

또한 자원을 프로세스가 선점할 수 있도록 하는 방법은 CPU와 같을 일부 자원에서는 가능하지만 모든 자원이 선점이 가능하지는 않으며, 원형으로 연결되지 않게 하기 위해 각 자원에 번호를 붙이고 오름차순으로 수행하는 방법이 있지만 이 역시 효율적으로 작업을 수행할 수 없는 문제가 있습니다.

### - 교착 상태 회피

`안전 순서열`이 있는 `안전 상태`의 경우에만 안전 순서열에 따라 자원을 할당하여 교착 상태를 회피하는 방법입니다.

#### 안전 순서열

> 교착 상태 없이 안전하게 프로세스들에게 자원을 할당할 수 있는 순서로, 프로세스에서 요구하는 자원량과 현재 사용중인 자원량이 있을 때, 모든 프로세스에서 최대로 자원 요구하는 최악의 상황을 가정하여도 교착 상태 없이 프로세스를 수행할 수 있는 순서를 말합니다.

#### 안전 상태

> 안전 순서열이 있는 상태, 안전 순서열이 없는 상태는 `불안전 상태`

### - 교착 상태 회복

교착 상태 회복을 위해서는 크게, 자원 선점을 통해 회복하는 방법과 프로세스 강제 종료를 통한 회복 방법이 있습니다.

#### 선점을 통한 회복

> 교착 상태를 유발한 프로세스에서 자원을 강제로 회수하여 다른 프로세스에 할당하는 방법입니다. 선점할 자원은 교착 상태를 해소할 수 있는 자원을 선택(우선순위가 낮은 프로세스 또는 점유 자원이 많거나 희소한 프로세스)하여 일시 중지하고 자원을 회수하여 프로세스를 수행한 후 중지된 프로세스를 다시 실행합니다.

> 작업 손실을 최소화 할 수 있지만 구현이 복잡하고 자원을 선점하는 과정에서 성능이 저하될 수 있습니다.

[⬆목차](#목차)

## 6. 메모리 관리

### - 연속 메모리 할당

연속 메모리 할당은 메모리의 빈 공간에 최초 적합, 최적 적합, 최악 적합 알고리즘을 통해 할당됩니다.

#### 1. 최초 적합

가장 먼저 발견된 프로세스 크기보다 크거나 같은 빈 공간에 프로세스 할당하여 빠르지만 `외부 단편화*` 가능성이 있습니다.

#### 2. 최적 적합

프로세스 크기와 가장 비슷한 크기의 빈 공간에 프로세스를 할당합니다. `내부 단편화*` 감소하지만 탐색 시간이 오래걸립니다.

#### 3. 최악 적합

가장 큰 빈 공간에 프로세스를 할당하여 큰 블록을 나누어 다른 프로세스에 할당할 수 있는 가능성이 증가하지만 외부 단편화 가능성이 증가합니다.

#### 외부 단편화\*

> 메모리의 사용 가능한 공간이 총량적으로는 충분하지만 연속된 공간이 부족하여 프로세스를 할당할 수 없는 문제

#### 내부 단편화\*

> 프로세스가 요구한 메모리보다 큰 공간에 할당되어, 사용되지 않는 메모리 공간이 낭비되는 문제

### - 압축

단편화를 해결하기 위한 하나의 해결 방법으로 메모리의 빈 공간을 한곳에 모아 연속적인 메모리 공간을 생성하는 방법입니다. 하지만 추가적인 오버헤드가 발생합니다.

### - 페이징

역시 단편화를 해결하기 위한 방법으로 연속 메모리 할당 방식을 제거하고, 프로세스를 페이지 단위로 분할하여 비연속 적으로 할당하는 방법입니다. (그리고 페이지는 `Swap*`을 사용할 수 있습니다.)

#### Swap\*

> 운영체제가 물리적 메모리(RAM)이 부족할 때, 디스크의 일부를 임시 저장 공간으로 사용하는 기술입니다.

프로세스의 가상 메모리를 일정 크기로 나누고(페이지) 물리 메모리 역시 같은 크기로 나눕니다.(프레임) 그리고 페이지 테이블을 두어 가상 주소의 페이지와 물리적 메모리의 프레임을 매핑하며 이 정보를 가지고 프로세스는 가상 주소를 사용하여 메모리에 접근합니다.

페이징을 통해 외부 단편화를 제거하고 효율적으로 메모리를 사용할 수 있으며 가상 메모리를 통해 실제 메모리보다 큰 용량의 프로그램을 실행할 수 있습니다.(Swap) 하지만 페이지의 크기보다 작은 데이터는 페이지의 남은 공간이 생기게 되어 내부 단편화가 발생하고 페이지 테이블을 사용해야 하기 때문에 오버헤드가 발생하고 가상 주소를 물리적 주소로 변환하는 과정에서 CPU의 추가 작업이 필요합니다.

#### 페이지 폴트

Swap을 사용하여 보조기억장치의 Swap 영역을 메모리로 사용할 때, 메모리에서 페이지를 찾을 수 없으면 페이지 폴트가 발생하고 보조기억장치에 접근하여 해당 페이지를 로드합니다. 이 과정에서 성능이 저하될 수 있습니다.

### - 페이징 최적화

#### 1. TLB(Translation Lookaside Buffer)

자주 참조되는 페이지 테이블 항목을 캐시하여 주소 변환 속도를 향상시킵니다.

#### 2. 페이지 교체 알고리즘

페이지 부재가 발생했을때, 교체할 페이지를 결정할 알고리즘을 말합니다.  
(페이지 폴트에 효과적으로 대응하기 위한 방법)

#### 2-1. FIFO

가장 단순한 알고리즘으로 먼저 들어온 페이지를 먼저 보조기억장치로 내보냅니다.

#### 2-2. 최적 페이지 교체 알고리즘(Optimal)

앞으로 사용 빈도가 가장 낮은 페이지를 교체하는 방법입니다. 가장 낮은 페이지 폴트율을 보장하지만 실제 구현이 어렵기 때문에 다른 페이지 교체 알고리즘의 성능을 평가하기 위해 사용됩니다.

#### 2-3. LRU(Least-Recently-Used)

최적 페이지 교체 알고리즘과 유사하지만 구현 가능한 알고리즘으로, 지금까지 사용 빈도가 가장 낮은 페이지를 교체하는 방법입니다.

### - 스래싱(Thrashing)

운영체제가 지나치게 많은 페이지 폴트를 처리에 대부분의 CPU 시간을 소모하여 실제 작업은 거의 수행하지 못하는 상태를 말합니다.

스래싱의 원인으로는

#### 1. 동적 집합

`동적 집합(Working Set)*`이 물리적 메모리 보다 크다면, 필요한 페이지가 메모리에 없는 경우가 많아집니다.

#### 동적 집합(Working Set)\*

> 프로세스가 실행 중 자주 참조하는 페이지 집합

#### 2. 프레임 부족

프로세스에 할당된 물리적 프레임이 부족하면, 자주 사용하는 페이지를 계속 스왑 인/아웃 해야 합니다.

#### 3. 과도한 멀티태스킹

동시에 실행되는 프로세스가 많아지면 각 프로세스가 충분한 메모리 프레임을 할당하지 못할 수 있습니다.

#### 4. 페이지 교체 정책

페이지 교체 알고리즘이 적절하지 않은 경우 자주 사용되는 페이지가 계속 스왑 인/아웃 될 수 있습니다.

### - 스래싱 해결

스래싱 문제를 해결하기 위해서는 각 프로스세스에 충분한 메모리 프레임을 할당하여 동적 집합이 메모리에 완전히 로드되도록 보장하고, 동시에 실행되는 프로세스 수를 줄여 각 프로세스에 더 많은 프레임을 할당받을 수 있도록 하며, 프로세스의 동적 집합 크기를 계산하고 필요한 메모리 크기를 동적으로 조정하고, 페이지 교체 알고리즘을 최적화 합니다.

[⬆목차](#목차)

## 7. 파일 시스템

### - 파티셔닝(Partitioning)

파티셔닝은 하나의 물리적 저장 장치를 여러 논리적 구역(파티션)으로 나누는 과정을 말하며 각 파티션은 독립된 논리 드라이브처럼 동작하며 별도의 파일 시스템을 가질 수 있습니다.

### - 포매팅(Formatting)

포매팅은 파티션에 파일 시스템을 설정하여 데이터를 저장할 준비를 하는 과정을 말하며 저장 장치의 데이터 구조를 초기화하고 저장 장치가 운영체제에서 인식되고 사용 가능하도록 만듭니다.

[⬆목차](#목차)
