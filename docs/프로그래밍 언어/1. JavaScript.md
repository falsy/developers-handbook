# JavaScript

자바스크립트는 다양한 환경(Node.js, 웹 브라우저 등..)의 다양한 자바스크립트 엔진(V8, SpiderMonkey, Chakra 등..) 위에서 동작합니다. 이 문서는 보편적으로 많이 사용되면서 정보가 많은 `웹 브라우저` 환경의 `V8` 엔진을 기준으로 작성하였습니다.

## 1. 자바스크립트 엔진

크게 언어는 `인터프리터 언어`와 `정적 컴파일 언어`로 나눌 수 있습니다. 인터프리터 방식은 코드를 실행 시점에서 라인 단위로 해석하여 기계어 코드로 실행하는 방식으로 대부분 스크립트 언어이며 JavaScript, Python, Ruby, PHP 등이 있습니다. 그리고 정적 컴파일 방식은 코드 실행 전에 전체를 컴파일하여 기계어로 변환된 실행 파일을 기반으로 동작하는 방식으로 C, Go, Swift, Rust 등이 있습니다.

하지만 현대 프로그래밍 언어 대부분은 인터프리터 방식과 컴파일 방식을 함께 사용하는 혼합형 실행 모델을 사용합니다. 그리고 자바스크립트 역시 인터프리터 언어로 출발하였지만, 현대 자바스크립트 엔진(V8, SpiderMonkey, JavaScriptCore 등)은 JIT 컴파일러와 프로파일링 최적화 기술을 사용하여 동작합니다.

#### JIT(Just-In-Time)

> JIT는 소스코드를 실행 직전 또는 실행 도중에 기계어로 컴파일하는 기술을 이야기합니다. 그리고 자바스크립트의 JIT는 여러가지의 최적화 기법을 활용하는데, 예를 들어 인라인 캐싱을 통해 동일한 키의 객체 프로퍼티를 자주 읽는 경우 이를 캐싱하여 프로퍼티의 접근 속도를 높이거나 타입 추론을 통해서 변수의 타입을 추론하여 정적 타입 언어처럼 최적화된 기계어를 생성하는 등이 있습니다.

자바스크립트 엔진이 코드를 해석할 때, 우선 자바스크립트 코드를 `추상 구문 트리(AST: Abstract Syntax Tree)`로 파싱합니다.

#### AST(Abstract Syntax Tree)

> AST는 프로그래밍 언어의 소스 코드 구조를 트리 형태로 표현한 데이터 구조로, 프로그래밍 언어의 문법을 계층적으로 나타냅니다. 이 정보를 가지고 컴파일러나 인터프리터가 코드를 이해하고 처리합니다.

자바스크립트 엔진은 자바스크립트 코드를 `렉싱(Lexing)`이라는 단계를 통해 소스를 읽어 키워드, 식별자, 연산자, 리터널 등..을 토큰으로 분해합니다. 그리고 토큰을 바탕으로 AST 트리를 생성합니다.

이제 생성된 AST 트리를 바탕으로 인터프리터 또는 컴파일러가 AST 트리를 `중간 표현(IR: Intermediate Representation)`으로 변환한 후 이를 기반으로 바이트코드를 생성합니다. 여기서 인터프리터는 바로 코드를 해석 후 실행하기에 빠르지만 반복적인 수행에 대해서 효율이 나쁘다는 문제가 있고 JIT 컴파일은 여러가지 최적화와 캐싱으로 반복 수행에 대해 빠르게 동작하지만 런타임 환경에서 수행되기 때문에 오버 헤드를 피할 수 없습니다. 또한 자바스크립트는 변수의 타입이 변할 수 있는 동적 언어이기 때문에 이는 정적 언어와 같은 최적화에는 한계가 있습니다.

그래서 최근의 자바스크립트 엔진들은 `적응형 JIT 컴파일(Adaptive JIT Compilation)`방식을 사용합니다. Adaptive JIT는 초기에 `Baseline JIT`가 간단화 최적화만을 수행하며 빠르게 바이트 코드로 변환하여 실행 가능한 초기 형태를 만듭니다. 그리고 실행 중에 코드를 분석하고 프로파일링하여 어떤 함수가 자주 호출되고 또 변수의 데이터 타입이나 반복문에서 사용되는 데이터 패턴 정보를 수집하여 자주 실행되는 코드를 중요도가 높은 `핫스팟`으로 설정하고 핫스팟으로 식별된 코드는 `Optimizing JIT`가 인라인 캐싱, 함수 인라이닝, 타입 추론 등의 최적화 기법을 사용하여 기계어로 변환합니다. 만약 Optimizing JIT를 통한 최적화 과정 중 문제가 생기면 최적화 전의 상태(Baseline JIT에서 생성된 바이트코드)로 되돌립니다.(`Deoptimization`)

마지막으로 간단하게 정리하자면, 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 `AST`를 만들고 AST를 가지고 `Adaptive JIT Compilation`방식을 사용하여 초기에 `Baseline JIT`가 바이트코드를 생성합니다. 그리고 런타임 중에 코드의 실행 빈도나 데이터 패턴들을 프로파일링하고 `Optimizing JIT`가 핫스팟으로 식별된 코드를 최적화하여 기계어로 변환합니다. 그리고 최종적으로 Baseline JIT에서 만들어진 바이트코드와 Optimizing JIT를 통해 만들어진 기계어를 통해 브라우저에서 실행됩니다.

## 2. 실행 컨텍스트(Execution Context)

실행 컨텍스트는 자바스크립트 코드가 실행될 때 생성되는 환경을 의미합니다. 크게 실행 컨텍스트는 변수, 함수 선언, this 바인딩 등의 `코드 실행 환경`을 설정하고 변수나 함수의 유효 범위인 `스코프 체인`을 관리하고 `호출 스택(Call Stack)`을 통해 실행 순서를 관리하는 역할을 합니다.

자바스크립트 코드가 처음 실행되면 `전역 실행 컨텍스트(Global Execution Context)`가 생성되며 전역 객체(window 또는 GlobalThis)와 연결되며 전역 변수와 함수를 관리하며 함수가 호출될 때마다 `함수 실행 컨텍스트(Function Execution Context)`가 생성됩니다. 함수 실행 컨텍스트에서는 함수 내부의 변수, 매개 변수, 함수 내부의 함수 등이 관리됩니다. 그밖의 eval() 함수가 호출될 때 생성되는 Eval 실행 컨텍스트(Eval Execution Context)가 있지만 일반적으로 사용이 권장되지 않습니다.

실행 컨텍스트의 생성 단계에서는 아래와 같은 과정을 수행합니다.

### - 스코프 체인(Scope Chain) 설정

현재 컨텍스트와 상위 컨텍스트를 연결하여 변수의 탐색 경로를 설정합니다.

### - 변수 객체(Variable Object) 생성

현재 컨택스트 스코프의 모든 변수와 함수 선언을 메모리에 저장합니다. 이때 함수 선언은 초기화되며, `var` 변수 선언은 `undefined`로 초기화 됩니다.

### - this 바인딩

전역 컨텍스트의 경우 window 또는 globalThis로 this 값을 바인딩하며 함수 컨텍스트의 경우 호출 방벙에 따라 결정됩니다.

위와 같이 생성된 실행 컨텍스트의 내부는 생성된 변수 객체가 저장된 `변수 환경(Variable Environment)`와 현재의 컨텍스트의 this 값, 그리고 현재 컨텍스트와 스코프 체인 정보를 포함한 `렉시컬 환경(Lexical Environment)`으로 구성되며 렉시컬 환경은 다시 두 부분으로 나뉘어 변수, 함수 등의 실제 바인드 정보를 가진 `환경 레코드(Environment Record)`와 상위 컨텍스트와의 연결 정보를 가진 `외부 렉시컬 환경 참조(Outer Lexical Environment Reference)`로 구성됩니다.

그리고 자바스크립트의 실행 컨텍스트는 `호출 스택(Call Stack)`을 사용해서 관리되며 가장 먼저 전역 컨텍스트가 생성되어 스택에 추가되고 함수가 호출되면 함수 컨택스트를 생성하여 다시 스택에 추가됩니다. 이후 마지막에 추가된 실행 컨텍스트부터 실행이 완료되면 해당 컨택스트부터 스택에서 제거됩니다.

#### 크롬 개발자 도구

> 크롬 개발자 도구의 브레이크 포인트를 활용하여 Call Stack과 Scope란을 통해 실행 컨텍스트를 확인할 수 있습니다. Scope란에서 전역 변수는 Global에 위치하며, var로 선언된 변수를 확인할 수 있으며 window 객체의 속성으로 바인딩 됩니다. 반면, 전역에서 const, let으로 선언된 변수는 Script에 위치하며 window 객체의 속성으로 바인드 되지 않습니다. 그리고 함수가 실행되어 Call Stack에 함수 실행 컨텍스트가 생성되면 Scope란에 Local에서 함수 내부에서 선언된 변수와 바인딩 된 this의 값을 확인할 수 있습니다.

## 3. 호이스팅(Hoisting)

실행 컨텍스트가 생성될 때, 변수와 함수 선언이 선언된 위치와 관계 없이 메모리에 먼저 등록됩니다. 이처럼 선언 자체가 코드가 실행되기 전에 끌어올려진 것처럼 동작하기 때문에 호이스팅이라고 불립니다.

`var`로 선언된 변수는 초깃값으로 `undefined`가 설정되어 `변수 객체(Variable Object: VO)`에 등록되며 함수 선언 역시 변수 객체에 등록되며 전체 함수는 메모리에 로드됩니다. `let`과 `const`로 선언된 변수는 변수 객체에 등록되지만 초기화 하지는 않으며 이는 `일시적 사각지대(TDZ: Temporal Dead Zone)`에 놓여 초기화 이전에 접근할 수 없습니다.

#### 일시적 사각지대(TDZ: Temporal Dead Zone)

> 변수가 선언되었지만 초기화도기 전까지의 시간을 말합니다. TDZ 상태의 변수에 접근하면 ReferenceError가 발생합니다.

## 4. 클로저(Closure)

일반적으로 함수가 실행을 마치면 실행 컨텍스트가 `호출 스택`에서 제거됩니다. 하지만 실행 컨텍스트의 `렉시컬 환경`의 `외부 렉시컬 환경 참조`에 의해서 내부 함수는 자신의 외부 렉시컬 환경을 기억하여 상위 스코프의 변수에 접근할 수 있습니다. 이렇게 함수가 선언될때의 렉시컬 환경을 기억하여 함수 외부에서 선언된 변수에 접근할 수 있는 특성을 클로저라 합니다.

외부 렉시컬 환경 참조에 의해 내부 함수에서 접근할 수 있는 외부 렉시컬 환경의 변수는 내부 함수를 통하지 않고는 접근할 수 없기 때문에 클로저는 데이터를 외부로부터 보호가 필요한 경우나 상태를 기억하는 함수를 생성하여 코드의 재사용성을 높이기 위해 사용됩니다.

#### 바운드 변수(Bound Variable)와 자유 변수(Free Variable)

> 함수 내부에서 직접 선언된 변수를 바운드 변수라고 하며, 함수 내부에서 선언되지 않고 외부 렉시컬 환경에서 정의된 변수를 자유 변수라고 합니다. 즉, 클로저를 통해 접근하는 변수는 자유 변수입니다.
