# ECMAScript

2020부터 2024까지 추가된 사양들을 가볍게 정리해 봅니다.

## 목차

- [1. ECMAScript 2020](#1-ecmascript-2020)
- [2. ECMASCript 2021](#2-ecmascript-2021)

## 1. ECMAScript 2020

### 1-1. BigInt

Number 타입이 안정적으로 나타낼 수 있는 최대치 '2^53 - 1'보다 큰 정수를 표현할 수 있는 내장 객체입니다. 뒤에 'n'을 붙이거나 'BigInt()'를 호출해 생성할 수 있습니다.

```js
// e.g. (MDN)
const theBiggestInt = 9007199254740991n
const alsoHuge = BigInt(9007199254740991)
```

> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt

### 1-2. Optional Chaining (?.)

객체의 프로퍼티가 존재하지 않아도 오류 없이 'undefined'를 반환합니다.

```js
const obj = {}
console.log(obj?.test)
// undefined
```

### 1-3. Nullish Coalescing Operator (??)

null 또는 undefined에 해당할 때만 기본값을 할당합니다.

```js
const a = null ?? "a"
console.log(a)
// 'a'
const b = 0 ?? "b"
console.lob(b)
// 0
```

### 1-4. Promise.allSettled

모든 Promise의 성공, 실패 여부와 관계 없이 결과를 배열로 반환합니다.

```js
const promises = [Promise.resolve("success"), Promise.reject("error")]

Promise.allSettled(promises).then((results) => console.log(results))
// [
//   { status: 'fulfilled', value: 'success' },
//   { status: 'rejected', reason: 'error' }
// ]
```

### 1-5. globalThis

브라우저와 Node.js 등 환경에 관계없이 전역 객체에 접근 가능합니다.  
(브라우저에서는 'window', Node.js 에서는 'global')

### 1-6. String.prototype.matchAll

matchAll은 match처럼 정규 표현식을 사용하는 메서드지만, match와 다르게 g 플래그가 필수이며 일치하는 항목과 위치(index), input 그리고 groups 값을 가진 이터레이터(반복 가능 객체)를 반환합니다.

```js
const str = "hello 123 world 456"
const regex = /(?<string>[a-z]+)/g

const result = str.matchAll(regex)
console.log([...result])
// [
//  ["hello", "hello", index: 0, input: "hello 123 world 456", groups: {string: "hello"}],
//  ["world", "world", index: 10, input: "hello 123 world 456", groups: {string: "world"}]
// ]
```

### 1-7. Dynamic Import (import())

import를 동적으로 사용할 수 있습니다.

```js
// module.js
export default function module() {
  return "module"
}
```

```js
async function loadModule() {
  const { default: module } = await import("./module.js")
  console.log(module())
  // "module"
}
loadModule()
```

### 1-8. export \* as

모듈을 한 번에 객체로 내보낼 수 있습니다.

```js
// module.js
export function moduleA() {
  return "moduleA"
}
export function moduleB() {
  return "moduleB"
}
```

```js
// index.js
export * as modules from "./module.js"
```

```js
// app.js
import { modules } from "./index.js"
console.log(moduels.moduleA())
// "moduleA"
```

### 1-9. for-in 루프 순서

ES2019까지 for-in 루프는 자바스크립트 엔진마다 키의 순서가 다를 수 있었는데, ES2020부터는 아래와 같이 값이 키 순서가 보장됩니다.

- 숫자 키(음이 아닌 정수): 오름차순 정렬
- 문자열 키: 객체에 추가된 순서

```js
const obj = {
  b: "B",
  a: "A",
  2: "two",
  1: "one",
}

for (const key in obj) {
  console.log(key)
}
// 1
// 2
// b
// a
```

[⬆목차](#목차)

## 2. ECMAScript 2021

### 2-1. String.prototype.replaceAll

기존 relace 메서드는 첫 번째 일치 항목만 변경했지만, replaceAll은 모든 일치 항목을 변경합니다.

```js
const str = "aaa, bbb, aaa"
console.log(str.replace("aaa", "ddd"))
// ddd, bbb, aaa
console.log(str.replaceAll("aaa", "ddd"))
// ddd, bbb, ddd
```

### 2-2. Promise.any

여러 개의 Promise 중에 가장 먼저 성공한 값(resolve)을 반환하며, 모든 Promise가 실패(reject)하면 AggregateError를 발생합니다.

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success 1")
  }, 300)
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success 2")
  }, 200)
})

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("error")
  }, 100)
})

Promise.any([promise1, promise2, promise3]).then((value) => {
  console.log(value)
})
// success 2
```

### 2-3. 논리 할당 연산자 (&&=, ||=, ??=)

#### AND 할당 (&&=)

값이 truthy면 새 값을 할당합니다.

```js
let a = 5
a &&= 10
console.log(a)
// 10

let b = 0
b &&= 10
console.log(b)
// 0
```

#### OR 할당 (||=)

값이 falsy면 새 값을 할당합니다.

```js
let a = 5
a ||= 10
console.log(a)
// 5

let b = 0
b ||= 10
console.log(b)
// 10
```

#### Nullish 할당 (??=)

값이 null 또는 undefined 일 때만 새값을 할당합니다.

```js
let a = null
a ??= 10
console.log(a)
// 10

let b = 0
b ??= 10
console.log(b)
// 0
```

### 2-4. WeakRef & FinalizationRegistry

메모리 관련 기능으로 객체를 약한 참조로 만들거나(WeakRef) 객체가 GC에 의해 삭제될 때 콜백을 실행(FinalizationRegistry)할 수 있습니다.

> 간단하게 요약하는 글이기 때문에 이 부분은 다음에 따로 포스팅을 하도록 하겠습니다.

### 2-5. Object.hasOwn()

기존에는 객체의 프로토타입 체인에서 상속된 hasOwnProperty 메서드를 사용하였지만 이는 객체의 프로토타입을 상속 받아야만 호출할 수 있으며 만약 객체에 hasOwnProperty 라는 속성이 있으면 오버라이드 될 수 있습니다.

```js
const obj = { hasOwnProperty: () => false, test: "test" }

console.log(obj.hasOwnProperty("test"))
// false
```

```js
const obj = Object.create(null)
obj.test = "test"

console.log(obj.hasOwnProperty("test"))
// TypeError: obj.hasOwnProperty is not a function
```

```js
const obj = Object.create(null)
obj.test = "test"

console.log(Object.hasOwn(obj, "test"))
```
