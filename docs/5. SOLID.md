# SOLID

객체 지향 프로그래밍에서 많이 이야기되는 객체 지향 프로그래밍 설계의 5가지 원칙인 SOLID에 대해 알아봅니다.

> '원칙'이라는 단어가 조금은 엄격하게 느껴질 수도 있지만, '객체 지향 프로그래밍' 자체가 방법론에 대한 이야기이기 때문에, 맞고 틀리고의 접근보다는 여기서의 이야기는 대체적으로 지향하는 방향을 가리키는 것 정도로 생각하면 좋을 것 같습니다.

## 단일 책임 원칙(SRP: Single Responsibility Principle)

하나의 클래스는 하나의 책임만 갖는다는 원칙입니다. 여기에서도 '책임'이라는 단어의 의미가 모호하여 많은 프로그래머들 사이에서도 의견이 분분한 것 같습니다.

> 이 글 역시 짧은 저의 생각일 뿐 정답이 아닙니다.

이전의 OOP글에서 클래스를 역할로 표현하였습니다. 즉 하나의 역할은 하나의 책임을 갖는다는 이야기가 됩니다. 편의점의 예를 들면 '청소하는 직원'에게는 편의점의 청소에 대한 하나의 책임을 갖게 해야 합니다. 현재 '청소하는 직원'에게는 청소에 대한 책임만 가지고 있기 때문에 단일 책임 원칙에 부합하는 것으로 보입니다. 하지만 조금 다르게 생각해 보면 '청소하는 직원'이 하는 일은 '창고 정리', '바닥 청소', '창문 청소', '화장실 청소'가 있습니다. 편의점이 아주 작다면 문제가 되지 않지만, 만약 아주 큰 편의점이라면 현재 '청소하는 직원'에게는 너무 많은 책임을 갖고 있는 것입니다.

> 이렇듯 '단일 책임 원칙'이라는 말은 이름 그대로 '하나의 클래스는 하나의 책임을 갖는다'라고 이해하기 보다는 '하나의 클래스가 갖는 책임은 해당 서비스의 규모나 복잡성에 맞춰 적당한 책임을 가져야 한다.'고 이해하는 것이 더 적합하지 않을까 생각합니다.  
> 그 이유는 '단일 책임 원칙'의 책임에 너무 매몰되다 보면 클래스가 무분별하게 많아질 수 있고 이는 오히려 프로그램의 유지 보수를 어렵게 할 수 있습니다. 그렇기 때문에 프로그램의 규모와 복잡도를 고려하여 설계하는 것이 중요한 것 같습니다.

위와 같이 편의점의 크기가 크다면(프로그램이 커지고 복잡하다면) '청소하는 직원'의 역할은 '창고 정리하는 직원', '화장실 청소하는 직원', '창문 청소하는 직원' 등으로 나누어 정의함으로 다시 각 역할에 하나의 책임을 갖게 하는 것이 '단일 책임 원칙'입니다.

이를 조금 다르게 이야기해 보자면, '책임'이라는 단어의 쓰임을 생각해 보면 어떠한 문제가 발생하였을 때 그 문제에 대한 대가를 감당해야 하는 것을 말합니다. 그리고 우리는 그 대가를 감당해야 하는 사람을 책임자라고 부릅니다. 즉, '단일 책임 원칙'을 잘 지킨다는 것은 어떠한 문제가 발생하였을 때, 그 책임자를 찾기 쉬워야 하고 그 책임의 범위가 작을수록 좋다는 의미입니다.

편의점의 예를 들면, 어느 날 편의점 사장이 편의점에 왔는데 창문이 아주 더러운 것을 확인하였습니다. 사장은 '청소하는 직원'들을 모두 불러서 화장실이 더러운 것에 대해 주의를 주어야 합니다. 이는 열심히 바닥을 청소하던 직원이나 화장실을 청소하던 직원에게 불필요하게 안 좋은 영향을 줄 수 있습니다. 만약 이때 '단일 책임 원칙'이 잘 지켜졌다면 '화장실 청소 직원'에게만 주의를 줌으로써 문제를 간편하게 해결할 수 있는 것입니다.

## 개방-패쇄 원칙(OCP: Open-Closed Principle)

클래스는 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙입니다.

편의점의 예로 들면, '계산하는 직원'의 하는 일에는 손님이 구매한 물건의 결제를 처리하는 일이 있습니다. 그런데 여기에는 다양한 결제 수단이 있을 수 있습니다. 현금 결제, 카드 결제, 포인트 결제 등.. 이렇게 결제 수단이 추가될 때마다 이 '계산하는 직원'은 손님이 구매한 물건의 결제를 처리하는 일에 조건이 추가되어야 하며 즉, 하는 일을 수정해야 합니다. 이 부분이 바로 '개방-폐쇄 원칙'의 '수정에는 닫혀 있어야 한다.' 부분과 맞지 않는 부분입니다.

이 부분을 수정하는 한 가지 방법으로 예를 들자면, '계산하는 직원'이라는 클래스를 '결제하기'와 같은 결제 로직의 '추상 메서드'를 갖는 '추상 클래스'로 정의하고 이를 상속받는 '현금을 계산하는 직원', '카드를 계산하는 직원', '포인트를 계산하는 직원' 등..으로 클래스를 나누어 정의하고 '계산하는 직원'의 위치에 필요에 따라 해당하는 직원이 일하게 합니다.

그리고 위와 같이 새로운 결제 수단이 추가되어도 새로운 클래스를 추가함으로써 계속 확장할 수 있는데 이 부분이 바로 '개방-폐쇄 원칙'의 '확장에는 열려있다.'라는 부분을 이야기합니다.

## 리스코프 치환 법칙(LSP: Liskov Subsitution Principle)

자식 클래스는 부모 클래스를 완전히 대체할 수 있어야 한다는 원칙입니다.

편의점의 예를 들어 '물건을 정리하는 직원'을 부모 클래스로 상속받은 '이벤트 상품을 진열하는 직원'이라는 기존의 물건을 정리하는 일에 확장해서 이벤트 상품을 돋보이게 진열하는 일까지 할 수 있는 자식 클래스가 있다고 했을때, '물건을 정리하는 직원'이 몸이 안 좋아서 갑자기 휴가를 써도, 자식 클래스인 '이벤트 상품을 진열하는 직원'은 적어도 부모 클래스가 기존에 하던 일을 완전히 대체하여 수행할 수 있어야 한다는 이야기입니다.

즉, 간단하게 이야기한다면 클래스를 '상속'을 하기 전에 이 클래스의 관계가 '상속'에 적합한 지, 그리고 자식 클래스에서 부모 클래스의 메서드를 오버라이딩(재정의) 한다면 부모의 의도와 다르게 오버라이딩 되지 않았는지 주의해야 한다는 원칙입니다.

## 인터페이스 분리 원칙(ISP: Interface Segregation Principle)

클래스는 자신이 사용하는 메서드에만 의존해야 한다는 원칙입니다. 조금 다르게 이야기한다면, 자신이 사용하지 않는 메서드에 구현을 강제해서는 안 된다는 이야기입니다.

> 여기에서 이야기하는 interface는 Java, C#, 또는 Swift의 protocol과 같은 개념으로 TypeScript에서 이야기하는 interface와는 조금 다른 개념입니다.

아까 이야기했던 '청소 마스터'라는 추상 클래스가 있고 이 추상 클래스에는 '걸레 빨기', '청소하기'의 추상 메서드를 가지고 있다고 했을 때, 이 추상 클래스를 상속받은 '물 청소 마스터', '창문 청소 마스터', '바닥 쓸기 마스터'가 있는데, 여기서 '바닥 쓸기 마스터'는 걸레를 사용하지 않는데, 추상 메서드로 '걸레 빨기'가 있기 때문에, 자신이 사용하지 않는 메서드를 구현해야 하는 상황이 되는데, 이 부분이 '인터페이스 분리 원칙'에 맞지 않는 부분입니다.

위와 같은 상황에서는 '청소 마스터'의 추상 클래스에 '걸레 빨기' 추상 메서드를 제거하거나 '바닥 쓸기 마스터'를 '청소 마스터'를 상속받지 않고 별개로 구현하는 방법 등의 수정 방법이 있습니다.

## 의존성 역전 원칙(DIP: Dependency Inversion Principle)

고수준 모듈이 저수준 모듈에 직접적으로 의존해서는 안 되며, 대신 추상화된 인터페이스에 의존해야 한다는 원칙입니다.

여기서의 고수준과 저수준은 추상화가 많이 될수록 고수준이며, 구체적일수록 저수준입니다. 고수준 모듈은 시스템의 상위 정책이나 로직을 구현하고, 저수준 모듈은 이를 지원하는 구체적인 작업을 수행합니다. 아주 간단히, 과일 클래스와 사과 클래스가 있다면, 과일은 사과와 같은 구체적인 클래스의 추상화된 상위 개념이므로 고수준의 클래스입니다.

다시 편의점의 예를 들면, 이전에 '개방-폐쇄 원칙'을 이야기할 때 '계산하는 직원'이라는 추상 클래스를 만들고 각 결제에 따라 구체 클래스를 정의했는데요, 이번에는 다르게 '계산하는 직원'이라는 클래스가 있고 '결제 처리기' 라는 추상 클래스를 정의합니다. '결제 처리기' 추상 클래스는 '결제 처리' 라는 추상 메서드를 가지고 있고, 이제 '결제 처리기' 추상 클래스를 상속받은 '현금 결제 처리기', '카드 결제 처리기', '포인트 결제 처리기'라는 구체 클래스를 정의합니다.

여기에서 '결제 처리기' 추상 클래스를 상속받은 '현금 결제 처리기', '카드 결제 처리기', '포인트 결제 처리기'는 구체적인 클래스로 '계산하는 직원'의 하위 개념으로 저수준의 클래스입니다. 즉, '계산하는 직원'은 '현금 결제 처리기', '카드 결제 처리기', '포인트 결제 처리기'와 같은 저수준의 클래스에 의존하지 않게 하는 것이 '의존성 역전 원칙'에 부합하는 것입니다. 대신 '계산하는 직원'은 추상화한 '결제 처리기'에 의존하여 로직을 구현해야 합니다.

만약 '계산하는 직원'이 '현금 결제 처리기', '카드 결제 처리기', '포인트 결제 처리기'와 같은 저수준의 클래스를 직접 의존하게된다면, 새로운 결제 방식이 추가될때마다 '계산하는 직원'에도 추가된 결제 방식에 대한 의존을 추가해야 하는 변경이 필요하게 되고 뿐만 아니라 결제 방식이 제거 되거나 변경될때마다 '계산하는 직원' 클래스도 변경을 해줘야 합니다. 이렇게 되면 클래스의 결합도가 높아지고 유연성도 떨어지며 점점 '계산하는 직원'의 코드가 복잡해져서 유지보수가 어려워지게 됩니다.
