# 객체 지향 프로그래밍(OOP: Object-oriented Programming)

> 이 글에 직접적인 코드 예시를 사용하고 있지는 않지만, TypeScript를 염두하여 작성하였기 때문에 Java나 C#의 Interface나 다형성 관련 부분은 포함되어 있지 않습니다.

우선, 프로그래밍이란?! 사람이 컴퓨터에게 명령을 내리는 행위를 이야기합니다.
일반적으로 가장 간단한 프로그래밍 방법은, 필요로 하는 일을 하나하나 컴퓨터에게 설명하는 방법인데 이는 내용이 장황해지고 반복이 많아 비효율 적이며, 이는 이후에 직관적이지 않고 방대한 양으로 인해 수정이 어려워지게 되는 문제가 있습니다.

이를 개선하기 위한 하나의 방법이 많은 반복이 일어날 것으로 예상되는 일을 별도로 묶어놓고 필요할 때마다 가져다 사용하는 방법입니다. 그리고 여기서 이 묶음이 바로 함수입니다. 이렇게 함수를 사용하여 순차적으로 컴퓨터에게 명령을 내리는 프로그래밍 방법을 절차 지향 프로그래밍이라고 합니다.

그리고 점점 프로그램이 커지고 복잡해지다 보면 이 방법으로는 기능 확장하거나 유지 보수하기에 어려워지게 됩니다. 예를 들어, 함수가 1,000개 이상으로 많아진다면 프로그램에 새로운 기능을 추가할 때, 필요한 함수를 찾기 어려워지고 이는 중복 함수를 만들 게 되어 함수의 수가 더 늘어나는 악순환이 될 수 있습니다. 또한 프로그램을 유지 보수하던 중 문제가 발생하였을 때, 많은 함수들의 각각의 의존성 때문에 수정이 어렵기 때문에 유지 보수가 힘들어집니다.

위와 같은 문제로 나온 방법이 객체 지향 프로그래밍으로, 사람도 일을 할 때 직업을 나누고 그 직업에 맞는 능력과 그 직업에 맞는 기능을 수행하는 것처럼 프로그램에 객체를 만들어서 각 객체마다 역할을 부여하여 일을 시키는 방법입니다.

현실 세계를 예로 들어보면, 편의점을 운영한다고 했을 때, 이전까지는 모든 직원들이 모든 일을 하고 있었는데 이제는 '계산하는 직원', '물건을 정리하는 직원', '청소를 하는 직원', '물건을 발주하는 직원' 등.. 이렇게 역할을 나눈 것입니다. 여기서 '계산하는 직원'의 상태를 속성으로 그리고 '계산하는 직원'이 하는 일을 메서드로 정의한 것이 하나의 클래스가 되는 것이고 실제로 편의점에서 일하는 직원은 '계산하는 직원' 클래스의 인스턴스가 되는 것입니다.

> 이 글에서는 이후, 계속 이 편의점을 예시로 사용합니다!

이렇게 역할을 클래스로 나눔으로써 프로그램을 확장할 때에는 확장 대상의 클래스를 변경을 하거나 또는 새로운 클래스를 추가하여 새로운 기능을 확장할 수 있고, 문제가 생겼을 때는 문제가 발생한 클래스만을 확인하고 수정하면 되기 때문에 유지 보수하기에 용이하게 됩니다. 이러한 프로그래밍 방법이 바로 객체 지향 프로그래밍입니다.

# Class

객체 지향 프로그래밍을 하기 위한 객체(Class)에 대한 특징에 대해 알아봅니다.

## 캡슐화

프로그래밍을 하다보면 많은 경우에, 어떠한 일을 처리할 때 특정 클래스가 독립적으로 이를 해결하지 않고 여러 클래스가 힘을 합쳐서 주어진 일을 해결하게 됩니다. 그리고 이렇게 여러 클래스가 함께 일을 해결할 때를 고려하여 각 클래스가 서로에 대해서 영향을 줄 수 있는 영역과 영향을 줄 수 없는 영향을 나누어 놓는데, 이를 캡슐화라고 합니다. 클래스가 정의될 때 외부에서 알 수 있고 사용할 수 있는 영역과 그렇지 않은 영역을 분명히 함으로써 각 클래스 간의 의존성을 낮추고 각 클래스가 자신의 역할에만 충실할 수 있도록 합니다. 그리고 이러한 명확한 부분은 전체적인 코드의 복잡성을 줄이고 클래스 자체의 유연성을 높여줍니다.

아까 이야기했던 편의점을 예로 들면, '물건을 정리하는 직원'은 자신의 역할인 '물건 정리'를 위해 편의점의 어떤 곳에 어떤 물건이 있고 현재 물건들의 재고가 어떻게 되는지 알고 있습니다. 그리고 '물건을 발주하는 직원'은 자신의 역할인 '발주'를 위해 어떠한 물건이 부족할 때 어떤 곳에 어떻게 발주해야 하는지 알고 있습니다.

여기서 '물건을 발주하는 직원'은 물건을 발주하기 위해서는 '물건을 정리하는 직원'에게 어떤 물건의 재고가 부족한지 확인해야 합니다. 이렇게 어떠한 일을 해결하기 위해서 여러 클래스가 함께 일을 해결하게 되는 일이 생기는 것이고 이때, '물건을 정리하는 직원' 클래스에게는 부족한 재고를 알려주는 메서드를 외부에서 알 수 있는 영역으로 설정하고 그리고 그 밖의 어떠한 물건이 어떤 곳에 있는지, 현재 물건들의 재고 상태가 어떤지 등은 외부에서 알 수 없도록 정의하여 클래스가 자신의 역할을 수행함에 있어 외부에 영향을 받지 않도록 하고 자신의 역할을 견고히 할 수 있도록 합니다. 이것이 바로 캡슐화입니다.

## 상속

프로그램이 점점 커지고 복잡해지면 어떠한 일을 해결하는 역할이 세분화되게 되는데, 이때 클래스는 상속을 통해서 자식 클래스에게 부모 클래스의 속성과 메서드를 물려줄 수 있습니다. 그리고 자식 클래스는 추가적인 자신의 세부적인 역할의 속성이나 메서드를 추가로 정의할 수 있고 또는 부모 클래스의 속성이나 메서드를 재정의할 수도 있습니다.

상속을 하지 않고 별개의 클래스를 추가로 정의할 수도 있지만, (만약 상속으로 구현이 가능함에도 별개의 클래스로 정의한다면) 불필요한 공통의 코드가 생성되는 것이고 이는 변경 사항이 생겼을 때 각각의 클래스 모두에게 변경해 줘야 하는 유지 보수의 어려움이 있습니다. 그리고 무엇보다도 클래스 간의 관계가 생성되지 않는 단점이 있습니다.

상속을 통해 생성된 자식 클래스는 부모 클래스의 속성과 메서드를 물려받습니다. 그리고 이는 부모 클래스가 사용되는 곳에 자식 클래스로 대체될 수 있음을 이야기합니다. 편의점의 예를 들어 이야기하자면, '계산하는 직원'은 현금 결제 기능만을 지원하는데, 이 역할을 상속받은 '카드 계산도 가능한 직원'을 정의한 것입니다. '카드 계산도 가능한 직원'은 상속을 통해 '계산하는 직원'의 속성과 메서드를 물려받았기 때문에 '계산하는 직원'이 휴가를 갔을 때의 공백을 '카드도 가능한 계산하는 직원'이 대체할 수 있습니다.

위와 같이 상속을 통한 클래스 들은 하나의 카테고리로 묶이게 되고, 이는 특정한 자리에 사용할 수 있는 클래스들의 묶음으로 정의되는 것입니다. 편의점의 예를 들어, 편의점 사장이 편의점의 계산대를 추가로 추가 하고 추가한 계산대의 위치할 사람을 정할 때, 고민 없이 '계산이 가능한 역할 묶음'('계산하는 직원'의 상속 클래스들의 모음) 중에 선택을 하면 됩니다.

나아가, 앞서 이야기한 클래스 간의 관계만을 위한 클래스도 있는데 이것이 바로 '추상 클래스'입니다. '추상 클래스'는 독립적으로 인스턴스를 만들 수 없고 클래스를 카테고리로 묶는 역할만을 합니다. 그리고 '추상 클래스'에는 그 역할을 의미하는, 반드시 정의되어야 하는(실제로 구체화되지는 않은) 메서드('추상 메서드')가 선언되어 있습니다.

편의점의 예를 들면 '청소 마스터'라는 이름의 '청소하기'라는 추상 메서드가 있는 '추상 클래스'를 정의하고 '청소 마스터'를 상속받은 '물 청소 마스터', '창문 청소 마스터', '바닥 쓸기 마스터' 등의 '청소하기'라는 메서드가 구현된 '구체 클래스'를 정의해서 '청소 마스터'의 위치에, 창문 청소가 필요하면 '창문 청소 마스터'를 위치 시키고 물 청소가 필요하면 '물 청소 마스터'를 위치시켜 '청소하기'라는 메서드를 사용하여 해당 기능이 동작하게 할 수 있습니다.
