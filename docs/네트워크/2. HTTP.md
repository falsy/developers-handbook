# HTTP

HTTP는 월드 와이드 웹(WWW)의 개발과 함께 도입된 프로토콜로, 초기에는 클라이언트의 GET 요청에 단순 텍스트 기반의 HTML 문서를 반환하는 역할을 했습니다. 이후, 웹 애플리케이션과 미디어 지원 필요성이 증가하면서 다양한 메소드(예: POST, PUT, DELETE)와 이미지, 동영상, 스크립트 같은 리소스의 지원 등 기능이 확장되었고 오늘날의 HTTP는 현대 네트워크 환경에 맞춘 최신 기술로, 낮은 지연과 보안을 기본 제공하며 클라이언트와 서버 간 통신뿐 아니라 다양한 환경에서 보편적으로 사용되는 핵심 통신 기술로 자리 잡고 있습니다.

## 목차

- [1. HTTP 역사](#1-HTTP-역사)
- [2. 버전별 특징](#2-버전별-특징)
  - [1. HTTP/0.9](#1-http09)
  - [2. HTTP/1.0](#2-http10)
  - [3. HTTP/1.1](#3-http11)
  - [4. HTTP/2](#4-http2)
  - [5. HTTP/3](#5-http3)

## 1. HTTP 역사

HTTP는 1989년 `팀 버너스리`의 월드 와이드 웹(World Wide Web) 프로젝트의 일환으로 만들어졌습니다. HTTP는 Hypertext Transfer Protocol의 약자로 이름 그대로 멀리에 있는 네트워크 기기 간의 Hypertext를 주고 받기 위해 고안된 프로토콜입니다.

#### Hypertext

> 하이퍼텍스트란 텍스트에 링크를 포함해서 한 문서에서 다른 문서로 즉시 이동할 수 있는 텍스트를 말합니다. 그리고 하이퍼텍스트 문서 내에서 직접 모든 형식의 자료를 연결하고 가리킬 수 있는 참조 고리를 하이퍼링크(Hyperlink)라고 합니다.

하이퍼텍스트 문서를 표현하기 위한 방법으로 HTML(Hypertext Markup Language)이라는 언어를 설계하였고 초기 HTML은 매우 간단한 마크업 언어로 하이퍼링크를 통해 문서간 이동이 가능하도록 설계되었습니다. 그리고 HTML 문서를 클라이언트(웹 브라우저)와 서버간의 주고 받기 위해, 네트워크 프로토콜이 필요했고 이를 위해 HTTP가 설계되었습니다.

초기 버전은 0.9 버전이라고 부르며 이는 단순히 HTML 문서를 텍스트 형태로 전송하는 역할만을 하였고 이후 HTML과 HTTP는 계속 발전하여 현대의 웹 기술의 기반이 되었습니다.

[⬆목차](#목차)

## 2. 버전별 특징

## 1. HTTP/0.9

HTTP의 초기버전으로 아주 간단하고 제한적인 특징을 가지고 있습니다. 처음부터 0.9버전이었던 것은 아니고 1.0 버전 이전의 버전이라는 의미로 0.9버전이 되었습니다.

### 1. GET 요청만 지원

```sh
GET /index.html
```

와 같이 추가적인 헤더나 프로토콜 버전 정보 없이 단순한 `GET /리소스` 형식으로 이루어져있습니다.

### 2. 헤더가 없음

클라이언트와 서버 간에 주고 받는 요청과 응답에 헤더 정보가 없었기에, 언어, 인코딩, 쿠키, 상태 정보등을 주고받지 않고 단순히 HTML 파일의 내용만을 전달할 수 있습니다.

### 3. HTML 응답만 지원

HTML 텍스트 응답만 지원하여 다른 형식의 파일들 예를 들면 이미지, CSS, JavasSript, 등이 지원되지 않았으며, HTML에 포함된 모든 리소스는 별도로 처리가 필요 합니다.

### 4. 응답 상태 코드가 없음

상태 코드 예를 들면 200, 404, 500 등.. 이 없기 때문에 요청한 리소스를 찾으면 HTML 콘텐츠를 바로 반환하고 그렇지 않다면 응답이 없거나 연결이 끊어집니다.

### 5. 비연결형 통신

클라이언트가 서버에 요청을 보내면 서버는 요청에 응답한 후 바로 종료하였습니다. 그래서 단순하고 가벼운 통신은 가능했지만 다수의 리소스를 한 번에 전송하는 데 비효율적입니다.

### 6. 단일 리소스

한 번의 연결에 하나의 리소스만 요청할 수 있습니다. 예를 들어, 웹 페이지에 여러 리소스를 포함하고 있다면 각각의 리소스를 별도의 요청으로 받아와야 합니다.

[⬆목차](#목차)

## 2. HTTP/1.0

0.9와 비교해 많은 기능들이 추가되어 현대적인 웹 브라우저 기반을 다진 버전입니다.

### 1. GET, POST, HEAD 메서드 지원

기존의 GET 외에도 서버에 데이터를 전송하며 데이터베이스 업데이트나 파일 업로드에 사용하는 `POST`와 GET과 유사하지만 실제 데이터 대신 헤더 정보만 반환하여 요청한 리소스의 메타데이터를 얻을 수 있는 `HEAD` 메서드가 추가되었습니다.

### 2. 헤더 도입

아래와 같은 요청과 응답에 메타데이터를 포함하는 헤더를 사용할 수 있게 되었습니다.

- Content-Type: 서버가 반환하는 데이터의 MIME 타입 (예: text/html, image/jpeg, 등..)
- Content-Length: 반환할 데이터의 바이트 단위의 크기
- Date: 응답이 생성된 날짜와 시간
- Server: 서버의 소프트웨어 정보
- User-Agent: 클라이언트 정보 (예. 브라우저)

### 3. 상태 코드 도입

상태 코드가 추가되어 요청의 성공 여부나 에러 발생 여부를 알 수 있게 되었습니다.

- 200 OK: 요청이 성공적으로 처리됨
- 404 Not Found: 요청한 리소스를 찾을 수 없음
- 500 Internet Server Error: 서버에서 요청 처리중 오류 발생

### 4. MIME 타입 지원

다양한 파일 형식을 지원하는 MIME(Multipurpose Internet Mail Extensions) 타입을 지원하여 HTML 이외에도 이미지, 비디오, 스크립트 등 다양한 파일 형식을 주고 받을 수 있게 되었습니다.

### 5. 비연결형 통신

기본적으로 0.9와 같이 비연결 통신으로 헤더의 Connection의 기본 값이 `close`이며 Connection 값을 `keep-alive` 헤더를 사용하여 서버와의 연결을 일정 시간 동안 유지할 수 있었지만, 많이 사용되지는 않았습니다.

```sh
GET /index.html HTTP/1.0
Connection: keep-alive
```

### 6. 캐시 제어

클라이언트가 서버로부터 받은 데이터를 재사용할 수 있도록 캐시와 관련된 헤더가 추가되었습니다. 대표적인 헤더는 아래와 같습니다.

- Expires: 이 응답의 유효한지를 나타냅니다.
- Last-Modifed: 리소스가 마지막으로 수정된 시간 정보를 나타냅니다.
- If-Modified-Since: 클라이언트가 리소스를 다시 요청할 때, 이전에 받은 리소스가 수정되었는지 확인하는데 사용합니다.

#### \*If-Modified-Since 시나리오

만약에 클라이언트가 서버에게 요청하여 index.html을 응답을 받았고 이때 Last-Modified 값이 포함되어 있었고,

```sh
Last-Modified: Tue, 22 Aug 2024 12:00:00 GMT
```

클라이언트가 다시 index.html을 요청할 때 헤더에 `If-Modified-Since` 값을 포함하여 요청합니다.

```sh
GET /index.html HTTP/1.0
If-Modified-Since: Tue, 22 Aug 2024 12:00:00 GMT
```

서버는 해당 시간 이후로 수정이 되었는지 확인하여, 수정이 되지 않았다면, `304 Not Modified` 상태 코드를 반환하여 클라이언트가 로컬에 캐시된 파일을 그대로 사용할 수 있도록 합니다.

```sh
HTTP/1.0 304 Not Modified
```

만약 수정이 되었다면 `200 OK` 응답과 함깨 파일을 응답합니다.

```sh
HTTP/1.0 200 OK
Last-Modified: Wed, 23 Aug 2024 15:30:00 GMT
```

### 7. 프록시 지원

클라이언트와 서버 사이에 중계 서버를 두고 데이터를 주고 받을 수 있도록 프록시를 지원하였습니다. 이를 통해 중복 요청을 줄이고 네트워크 성능을 향상시키며, 보안 및 로드 밸런싱 기능을 제공할 수 있습니다.

[⬆목차](#목차)

## 3. HTTP/1.1

이전까지 웹에서 가장 널리 사용되는 버전으로 1.0 버전의 여러 문제를 해결하고 성능이 향상되었습니다.

### 1. 지속적인 연결 기본 지원

HTTP 1.1 부터 지속적인 연결을 기본으로 사용하여 헤더의 `Connection: keep-alive`를 명시적으로 요청할 필요가 없으며 매 요청마다 새로운 연결을 만드는 오버헤드를 줄였습니다.

### 2. 파이프라이닝 지원

클라이언트가 여러개의 요청을 순차적으로 기다리지 않고 한 번에 보낼 수 있는 기능이 도입했습니다. 이를 통해 통신 요청 간의 지연시간을 줄여 성능을 개선하였습니다. 단 이 기능은 각 요청을 받은 순서대로 응답해야해서, 서버의 능력에 따라 성능이 다를 수 있습니다. 그리고 웹 브라우저에서는 파이프라이닝을 잘 사용하지 않았습니다.

> 만약 첫번째 요청이 대용량 파일 다운로드와 같이 오랜 시간이 걸리는 작업을 처리하는 경우 뒤에 이어진 두 번째, 세 번째 요청의 응답이 준비가 되었더라도 첫번째 요청을 기다려야하는 병목 현상이 생기기 때문에 이와 같은 경우에는 성능상 큰 이점을 얻지 못할 수 있습니다.

> 2024년 현재의 모던 브라우저에서도 앞서 이야기한 병목 현상을 비롯해서 서버와 클라이언트 간의 호환성 문제로 안정적인 성능 보장이 어려워 파이프라이닝을 거의 사용하지 않고 있다고 합니다. 대신 모던 브라우저들은 HTTP/2와 HTTP/3을 통해서 더 효율적인 성능을 제공하고 있습니다.

#### \*Domain Sharding

추가로 브라우저에서는 파이프라니닝 대신 효과적으로 통신하기 위해 도메인마다 여러개의 TCP 연결을 동시에 생성해 여러 리소스를 한 번에 다운로드 하도록 하였고 대략 6개(~ 8개) 정도의 동시 연결을 지원합니다.

여기에서 브라우저에서 지원하는 동시 연결 수 이상을 사용하기 위해, 같은 IP 주소의 서브 도메인을 나누어 사용하는 방법을 `Domain Sharding`이라고 합니다. 하지만 서브 도메인의 DNS 조회 비용이나 초기 TCP 연결의 오버헤드, 브라우저의 메모리 및 CPU 사용량 증가 등의 이유로 기대 만큼의 성능 향상을 보장하지는 않았습니다.

### 3. 호스트 헤더 필수

HTTP 1.0 에서는 요청할 때 서버의 IP 주소만으로 처리할 수 있었지만, 여러 도메인이 동일한 IP 주소를 공유하는 경우가 늘어남에 따라 가상 호스팅이 등장했고 이를 지원하기 위해 Host 헤더를 필수로 사용하였습니다.

```sh
GET /index.html HTTP/1.1
Host: falsy.me
```

### 4. 캐시 제어 강화

HTTP 1.0에서 제공하던 기본적인 캐시 매커니즘을 확장하고 강화했습니다.

- Cache-Control: 리소스가 어떻게 캐시되어야 하는지 세부적으로 제어할 수 있습니다.  
  (예: Cache-Control: no-cache = 클라이언트가 캐시된 데이터를 사용하지 않고 새로운 최신 데이터를 요청하도록 강제 합니다.)
- ETag: 리소스의 특정 버전을 나타내느 고유 식별자를 제공합니다.
- If-None-Match: ETag와 함께 사용되며 클라이언트가 ETag 값을 보내 리소스가 변경되지 않은 경우 `304 Not Modifed` 응답을 받을 수 있습니다.

#### \*HTTP/1.0 Last-Modified / If-Modified-Since 와 차이

Last-Modified는 초단위로만 비교가 가능하여 1초 이내의 수정사항은 변경사항을 감지하지 못할 수 있으며 서버와 클라이언트의 시간 동기화 문제, 그리고 서버의 파일 시스템 타임스탬프에 의존하므로 일부 시스템에서 정확하지 않을 수 있습니다. 그에 반해 ETag는 바이트 단위의 변경도 감지하고 변경될 때마다 ETag 값도 변경되어 정확하게 변화를 감지할 수 있습니다.

### 5. 청크 전송 인코딩 지원

청크 전송 인코딩을 지원하여 서버가 콘텐츠의 크기를 미리 알 수 없는 경우에도 데이터를 전송할 수 있습니다. 응답 데이터를 청크 단위로 나누어 전송하고 각 청크의 크기를 헤더에 포함하여 전송합니다.

```sh
Transfer-Encoding: chunked
```

### 6. HTTP 상태 코드 확장

HTTP 1.1은 HTTP 1.0에서 사용하던 상태 코드 외에도 여러 새로운 상태 코드를 도입했습니다.

- 100 Continue: 클라이언트가 요청을 보내기 전에 서버로부터 요청을 계속해도 된다는 응답을 받을 때 사용.
- 206 Partial Content: 클라이언트가 요청한 리소스의 일부분만 전송될 때 사용. 이는 파일 다운로드 시 특정 범위를 요청하는 기능에서 사용됩니다.
- 409 Conflict: 클라이언트의 요청이 서버 상태와 충돌할 때 발생.
- 411 Length Required: 요청에 Content-Length 헤더가 없을 때 발생.

### 7. 범위 요청 지원

클라이언트에서 서버의 특정 파일의 일부만 요청할 수 있는 범위 요청(`Range Request`)를 지원합니다. 이는 대용량 파일을 다운로드할 때 중간에 중단된 경우, 남은 부분만 다시 다운로드할 수 있게 해줍니다.

```sh
Range: bytes=500-999
```

서버는 이 요청에 대해 `206 Partial Content` 상태 코드를 반환합니다.

### 8. 압축 전송 지원

데이터 전송중 콘텐츠 인코딩을 통해 데이터 압축을 지원합니다. 클라이언트가 `Accept-Encoding` 헤더를 통해 지원하는 압축 방식을 서버에 알리고 서버는 해당 방식으로 압축하여 전송할 수 있습니다.

```sh
Accept-Encoding: gzip, deflate
```

> 일반적으로 gzip을 많이 사용하곤 하는데, 압축의 오버헤드와 압축 비율의 한계등으로 인해 이미 압축된 이미지나 영상 파일(예: JPEG, PNG, PM4 등..) 또는 크기가 작은 파일(예: 1KB 이하)은 gzip을 생략하도록 설정하는 것이 더 성능에 좋을 수 있습니다.

### 9. OPTIONS 및 PUT, DELETE 메서드 지원

HTTP 1.1은 HTTP 메서드의 종류를 확장하여 OPTIONS, PUT, DELETE 메서드를 추가로 지원합니다.

- OPTIONS: 서버에서 지원하는 메서드를 확인할 때 사용됩니다.
- PUT: 클라이언트가 서버에 리소스를 업로드하거나 데이터를 갱신할 때 사용됩니다.
- DELETE: 서버의 리소스를 삭제할 때 사용됩니다.

[⬆목차](#목차)

## 4. HTTP/2

이전까지 HTTP/1.1이 널리 사용되었지만, 오늘날(2024년)에는 대부분의 모던 웹 브라우저와 서버에서 기본적으로 지원하는 버전입니다. 특히 웹 페이지 로딩 성능 개선을 위해 많은 최적화 기능이 도입되었습니다.

> [웹 브라우저 지원]  
> Window 10 환경의 IE 11 이후  
> Android v.7(누가) 이후  
> iOS v.9 이후  
> Safari v.9 이후

### 1. 멀티플렉싱

HTTP/2의 핵심 기능 중 하나로 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있는 기능입니다. HTTP/1.1의 파이프라닝과 달리 요청과 응답이 독립적으로 전송되어 병목 현상이 없고 웹 페이의 다수의 리소스(CSS, JavaScript, 이미지 등..)을 한번에 전송할 수 있어 성능이 크게 향상되었습니다.

### 2. 헤더 압축

HTTP/2는 `HPACK`이라는 새로운 방식의 헤더 압축을 사용하여 전송량을 줄이고 성능을 최적화 합니다. 그리고 서버와 클라이언트가 이미 전송한 헤더값을 캐싱하여 불필요한 반복 전송을 방지합니다.

### 3. 서버 푸시

서버 푸시는 클라이언트가 요청하지 않은 리소스도 서버가 미리 클라이언트에게 전송할 수 있는 기능입니다.

### 4. 스트림 우선순위

여러 개의 요청을 동시에 전송될 때 각 요청의 우선순위를 지정할 수 있습니다. 이를 통해 브라우저는 중요한 리소스 HTML, CSS 부터 다운로드하고 덜 중요한 이미지나 광고 스크립트 같은 리소스는 나중에 다운로드 하도록 할 수 있습니다. 우선순위는 클라이언트가 서버에 요청할 때 우선순위를 명시하거나 서버에서 요청 중요도에 따라 조정할 수 있습니다.

### 5. 이진 프레이밍

HTTP/1.1은 텍스트 기반의 프로토콜이었던 반면, HTTP/2는 모든 데이터를 이진 프레임으로 전송합니다. 이를 통해 데이터가 더 효율적으로 전달되고 프로토콜 해석도 빠르고 오류가 적어졌습니다.

이진 프레임은 아래와 같은 방식으로 전달됩니다.

- 프레임: 기본 전송 단위로 데이터와 제어 정보가 포함됩니다. 하나의 요청과 응답은 여러개의 프레임으로 나눠 전성될 수 있습니다.
- 스트림: 여러 프레임이 모여 하나의 요청 또는 응답을 구성하는 논리적 채널이빈다. 하나의 연결에서 여러 스트림이 동시에 전송될 수 있습니다.
- 메시지: 스트림을 통해 전송된 프레임들의 완전한 집합으로 클라이언트의 요청 또는 응답을 의미합니다.

### 6. 단일 연결

하나의 TCP 연결만으로 다수의 요청과 응답을 처리할 수 있습니다. 또한 TLS(SSL) 연결도 한 번만 설정되면 여러 요청을 처리할 수 있어서 보안 통신의 선능도 개선되었습니다.

### 7. 대역폭 사용 최적화

네트워크의 대역폭을 더 효율적으로 사용하기 위해 스트림에서 `Flow Control` 이라는 매커니즘을 사용하여 클라이언트와 서버 간의 데이터 전송 속도를 조절하여 네트워크 혼잡을 방지하고 대역폭을 최적화 합니다. 이 기능으로 대용량 파일을 다운로드 하거나 많은 리소스를 동시에 요청할때 네트워크가 효율적으로 관리합니다.

### 8. 백워드 호환성

HTTP/2를 지원하지 않는 클라이언트나 서버는 여전히 HTTP/1.1로 통신할 수 있으며 필요에 따라 HTTP/1.1로 자동 전환됩니다.

[⬆목차](#목차)

## 5. HTTP/3

HTTP/3의 가장 큰 변화는 TCP 대신 UDP 기반의 QUIC 프로토콜을 사용합니다. TCP의 3-Way Handshake와 같은 과정을 없애고 최초 요청시 곧바로 데이터를 전송할 수 있어서 네트워크 성능을 크게 향상시켰습니다.

> [웹 브라우저 지원]  
> Edge v87 이후 (2020-11)  
> Chrome v87 이후 (2020-11)  
> Safari v16.4 이후 (2023-03)  
> Firefox v88 이후 (2021-04)

### 1. 0-RTT (Zero Round-Trip Time) 연결 설정

0-RTT 연결이란 클라이언트가 서버와 연결을 설정하면 동시에 데이터를 전송할 수 있음을 이야기합니다.

> RTT(Round-Trip Time) 패킷이 목적지에 도착하고 다시 출발지로 돌아오기까지의 시간, 즉 패킷의 왕복 시간입니다. RTT에는 많은 요소들을 영향을 주지만 예를 들어 물리적인 거리도 영향을 주는 요인으로 RTT를 줄이기 위해 CDN을 사용하는 것이 하나의 예시 입니다.

### 2. 스트림 간 독립성

HTTP/2는 멀티플렉싱 기능을 도입하여 한 번에 여러개의 요청을 처리할 수 있게 하였지만 기본적으로 TCP 연결은 네트워크 통신간에 패킷이 손실되면 해당 패킷이 도착할 때까지 모든 스트림을 기다려야하는 문제가 있습니다(Head-of-Line Blocking). HTTP/3에서는 각 스트림이 독립적으로 동작하기 때문에 패킷의 손실이 발생하더라도 다른 스트림에 영향을 주지 않고 이는 웹 페이지의 로딩 속도를 크게 향상시킵니다.

### 3. 빠른 복구와 신속한 연결 재설정

QUIC는 네트워크 통신간에 발생하는 패킷 손실에 대해 더 빠르고 효율적인 복구 매커니즘을 제공합니다. QUIC는 UDP를 사용하여 패킷이 손실된 경우에도 별도의 연결을 설정하지 않고 빠르게 데이터 전송을 이어갑니다.  
또한 연결 상태를 유지하면서 연결이 중단된 경우에도 복구가 빠릅니다. 예를 들어 Wi-Fi 에서 LTE 네트워크로 전환하는 경우도 기존의 연결이 유지되며 재연결에 거의 시간이 들지 않습니다.

### 4. 연결 재사용 및 유지

TCP 기반의 HTTP/2에서는 IP 주소나 포트 번호가 바뀌면 연결이 끊어졌지만, QUIC는 커넥션 ID를 통해서 IP 주소가 변경되더라도 연결이 끊어지지 않고 커넥션 ID를 통해 연결을 유지할 수 있습니다. 앞서 이야기와 동일하게
Wi-Fi 에서 LTE 네트워크로 전환되더라도 연결이 끊어지지 않고 안정적으로 통신할 수 있습니다.

### 5. 통합된 보안

HTTP/3은 기본적으로 TLS 1.3을 사용하여 이전 버전보다 빠르고 안전한 연결을 제공합니다.

### 6. 백워드 호환성

HTTP/3 역시 백워드 호환성을 지원하여 HTTP/3를 지원하지 않는 서버나 클라이언트는 여전히 HTTP/2 또는 HTTP/1.1을 사용할 수 있습니다.

[⬆목차](#목차)
