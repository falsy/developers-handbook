# SQL

## Reference

이 문서는 [한빛미디어](https://www.youtube.com/@HanbitMedia93)의 유튜브 강의([혼자 공부하는 SQL](https://www.youtube.com/watch?v=0cRhit1EJM0))와 추가로 공부한 내용을 함께 정리한 문서입니다.

## 목차

- [1. 제약조건](#1-제약조건)
- [2. 인덱스(Index)](#2-인덱스index)
- [3. 커서(Cursor)](#3-커서cursor)
- [4. 트리거(Trigger)](#4-트리거trigger)

## 1. 제약조건

데이터베이스에서 제약조건은 데이터의 무결성과 일관성을 유지하기 위해 테이블에 적용하는 규칙을 말하며 일반적으로 `무결성 제약조건`, `도메인 제약조건`, `참조 무결성 제약조건` 이렇게 세 가지 주요 제약조건으로 나눌 수 있습니다.

### - 무결성 제약조건

`무결성 제약조건`은 데이터의 정확성과 일관성을 보장하기 위한 제약조건을 말합니다.

#### 1. 기본 키(Primary Key)

테이블에서 각 행을 교유하게 식별하는 데 사용합니다. 중복되는 값을 사용할 수 없고, NULL 값을 사용할 수 없습니다.

#### 2. 외래 키(Foreign Key)

다른 테이블의 기본 키를 참조하여 두 테이블 간의 관계에 사용합니다. 참조 무결성을 보장하기 위한 키로 기본적으로는 외래 키가 설정된 부모 테이블의 데이터를 삭제하거나 기본 키값 수정에서 오류를 발생시키며 `ON DELETE`, `ON UPDATE` 옵션을 사용하면 부모 테이블의 변경사항이 자식 테이블에도 영향을 주어, 연결된 자식 테이블의 데이터도 삭제되거나 자식 테이블의 외래 키값도 함께 변경됩니다.

#### 3. 유니크(Unique)

열의 값이 고유하도록 보장합니다. 데이터베이스에 따라 차이가 있지만 일반적으로 NULL을 허용할 수 있습니다.

#### 4. 체크(Check)

열의 값이 특정 조건을 만족해야 한다는 것을 지정할 수 있습니다. (e.g. age > 18)

#### 5. NOT NULL

열의 값이 NULL 값을 가질 수 없도록 제한합니다.

### - 도메인 제약조건

열에 저장될 수 있는 데이터의 유형과 형식을 제한합니다.

#### 1. 데이터 타입

열의 값이 특정 데이터 타입이어야 합니다. (e.g. VARCHAR, INTEGER, DATE)

#### 2. 길이 제한

문자열의 최대 길이를 제한합니다. (e.g. VARCHAR(30))

#### 3. 값의 범위

값이 특정 범위 내에 있어야 합니다. (e.g. CHECK (salary BETWEEN 30000 AND 200000))

#### 4. 포맷 규칙

값이 특정 형식을 따라야 합니다. (e.g. 이메일 주소 형식)

### - 참조 무결성 제약조건

데이터의 관계를 유지하고 일관성을 보장하기 위한 제약조건입니다.

#### 1. 외래 키 제약조건

부모 테이블의 기본 키가 자식 테이블에서 참조될 때 데이터의 무결성을 보장합니다.

> 부모 테이블에서 데이터 삭제/수정 시 자식 테이블의 처리 방식을 설정 (CASCADE, SET NULL 등..)

#### 2. ON DELETE, ON UPDATE

부모 데이터가 변경되었을 때 자식 데이터가 어떻게 반응할지 지정합니다.

- CASCADE: 부모 데이터가 삭제되거나 수정되면 자식 데이터도 동일하게 처리
- SET NULL: 부모 데이터가 삭제되면 자식 데이터는 NULL로 설정
- NO ACTION: 기본값으로, 부모 데이터 삭제/수정 시 데이터에 영향 없음

[⬆목차](#목차)

## 2. 인덱스(Index)

테이블의 데이터를 빠르게 검색하기 위해 사용하는 데이터 구조로 인덱스는 책의 색인처럼 특정 데이터를 빠르게 찾을 수 있도록 합니다. 일반적으로 `B-트리` 또는 해시(Hash) 구조를 사용하여 구현되며 인덱스를 사용하면 검색, 정렬, 그룹화 속도가 빨라지지만 삽입, 삭제, 갱신 시 약간의 오버헤드가 발생합니다.

### - 클러스터드 인덱스(Clustered Index)

클러스터드 인덱스는 테이블에 하나만 생성 가능하며, 데이터 테이블 자체가 인덱스 순서에 따라 물리적으로 정렬됩니다. 즉, 데이터 자체를 정렬된 상태로 유지하며 인덱스와 데이터가 동일한 구조에 저장됩니다. 인덱스가 데이터 자체이기 때문에 검색 시 추가적인 참조 과정 없이 빠르게 검색되는 장점이 있으며 데이터가 삽입, 삭제, 갱신될 때 정렬 상태를 유지해야 하므로 `쓰기 성능`이 저하될 수 있습니다.

> 기본 키(PRIMARY KEY)로 설정하면 클러스터드 인덱스가 생성되고 해당 데이터를 기준으로 정렬됩니다. (MySQL, InnoDB 엔진)

### - 비클러스터드 인덱스(Non-clustered Index)

비클러스터드 인덱스는 테이블에 여러개 생성이 가능합니다. 비클러스터드 인덱스는 별도의 데이터 구조에 저장되며 인덱스는 데이터 테이블의 행을 참조합니다. 그렇기에 검색 시 인덱스에서 데이터를 찾고 해당 위치의 데이터로 이동하는 추가 작업이 필요하기 때문에 상대적으로 클러스터드 인덱스보다는 느릴 수 있습니다. 하지만 여러 열에 다양한 조건으로 검색이 가능하며 클러스터드 인덱스가 적용되지 않은 열에 대해서도 검색 성능을 향상 시킬 수 있습니다.

> 일반적인 index 설정은 기본적으로 비클러스터드 인덱스가 생성됩니다.

[⬆목차](#목차)

## 3. 커서(Cursor)

SQL은 일반적으로 `셋 기반(Set-based)` 언어로 SQL 쿼리는 테이블의 여러 행을 한꺼번에 처리합니다. 하지만 특정 작업에서는 각 행을 개별로 처리해야 하는 경우가 있는데, 이렇게 쿼리 결과로 반환된 여러 개의 행을 한 번에 처리하지 않고, 한 행씩 순차적으로 처리하기 위한 매커니즘이 `커서`입니다.

### - 커서의 동작 과정

#### 1. 커서 선언 (DECLARE)

사용할 커서를 선언합니다. 이 단계에서는 커서가 어떤 SELECT 쿼리를 사용할지 정의합니다.

#### 2. 커서 열기 (OPEN)

선언된 커서를 열어서 쿼리를 실행하고, 결과 집합을 메모리에 로드합니다.

#### 3. 행 읽기 (FETCH)

커서를 사용해 결과 집합의 행을 하나씩 가져옵니다.

#### 4. 커서 닫기 (CLOSE)

작업이 끝난 후, 커서를 닫아 메모리를 해제합니다.

#### 5. 커서 삭제 (DEALLOCATE)

커서를 완전히 제거합니다.

### - 커서의 장단점

커서는 겨로가 집합의 각 행마다 조건에 따라 다른 로직을 적용하는 것처럼 개별적으로 처리할 수 있어 복잡한 작업에 유리하지만, 결과 집합을 한번에 처리하는 셋 기반 처리에 비해 성능이 좋지 않고 커서가 메모리에 결과 집합을 저장하기 떄문에 대량의 데이터를 처리할 때 메모리 사용량이 증가할 수 있습니다.

[⬆목차](#목차)

## 4. 트리거(Trigger)

트리거는 데이터베이스에서 특정 이벤트가 발생할 때 자동으로 실행되는 SQL 명령어 집합을 말합니다.

### - 트리거 동작 과정

#### 1. 이벤트 발생

테이블에서 INSERT, UPDATE, DELETE 또는 DDL 작업(테이블 생성, 삭제 등)이 발생

#### 2. 트리거 실행

해당 이벤트에 연관된 트리거가 자동으로 실행

#### 3. 명령 수행

트리거에 정의된 SQL 명령 집합 실행

### - 트리거의 장단점

트리거는 데이터의 유효성을 보장하고 비즈니스 로직이나 데이터 변경 이력을 자동으로 저장할 수 있는 장점이 있지만, 자동으로 실행되기에 디버깅이 복잡해 질 수 있고 트리거가 많아지면 데이터베이스 관리와 유지보수가 어려워질 수 있습니다.

[⬆목차](#목차)
