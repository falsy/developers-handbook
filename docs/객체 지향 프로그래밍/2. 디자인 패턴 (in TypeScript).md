# 디자인 패턴 (in TypeScript)

## Reference

- [Refactoring.Guru](https://refactoring.guru/ko)(웹 사이트)
- [위키피디아](https://ko.wikipedia.org/)(웹 사이트)
- [얄팍한 코딩사전](https://www.youtube.com/@yalco-coding)(유튜브)
- [코드없는 프로그래밍](https://www.youtube.com/@코드없는프로그래밍)(유튜브)

## 목차

- 구조 패턴
  - [1. 어탭터 패턴](#1-어댑터-패턴)
  - [2. 브리지 패턴](#2-브리지-패턴)
  - [3. 컴포지트 패턴](#3-컴포지트-패턴)
  - [4. 데코레이터 패턴](#4-데코레이터-패턴)
  - [5. 퍼사드 패턴](#5-퍼사드-패턴)
  - [6. 플라이웨이트 패턴](#6-플라이웨이트-패턴)
  - [7. 프록시 패턴](#7-프록시-패턴)
- 생성 패턴
  - [1. 팩토리 메서드 패턴](#1-팩토리-메서드-패턴)
  - [2. 추상 팩토리 패턴](#2-추상-팩토리-패턴)
  - [3. 빌더 패턴](#3-빌더-패턴)
  - [4. 프로토타입 패턴](#4-프로토타입-패턴)
  - [5. 싱글턴 패턴](#5-싱글턴-패턴)
- 행동 패턴
  - [1. 책임 연쇄 패턴]
  - [2. 커맨드 패턴]
  - [3. 반복자 패턴]
  - [4. 중재자 패턴]
  - [5. 메멘토 패턴]
  - [6. 옵서버 패턴]
  - [7. 상태 패턴]
  - [8. 전략 패턴]
  - [9. 탬플릿 메서드 패턴]
  - [10. 비지터 패턴]

# 구조 패턴

## 1. 어댑터 패턴

호환되지 않는 객체들을 함께 사용할 수 있도록 해주는 패턴입니다. 어댑터라는 두 객체 사이의 래퍼(Wrapper) 역할을 하여 호환되지 않던 두 객체를 연결해줍니다. 특히 일부 레거시 코드를 기반으로 하는 서비스에 많이 사용됩니다.

예를 들어, 과거 CSV 형태의 값을 응답하는 객체가 있었고 현재는 JSON을 사용하여 프로그램을 구성하고 있을때, 이전 CSV 값을 응답하는 객체를, CSV 형태를 JSON 형태로 변경해주는 어뎁터 래퍼를 추가하여 현재의 프로그램에 호환될 수 있도록 하는 방법입니다.

```ts
class CsvMessage {
  requestCsvStr(): string {
    return `id,name,age\n1,boo,10`
  }
}
```

위와 같이 기존에 사용하던 CSV 형태의 데이터를 응답하는 객체가 있고

```ts
class JsonMessage {
  requestJsonStr(): string {
    return JSON.stringify([{ id: "2", name: "foo", age: "20" }])
  }
}
```

현재는 위와 같이 JSON 형태의 데이터 응답을 사용하고 있다면,

```ts
class AdapterMessage extends JsonMessage {
  private csvMessage: CsvMessage

  constructor(csvMessage: CsvMessage) {
    super()
    this.csvMessage = csvMessage
  }

  requestJsonStr(): string {
    const rows = this.csvMessage.requestCsvStr().split("\n")
    const headers = rows[0].split(",")
    const result = []

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i].trim()
      if (!row) continue

      const data = row.split(",")
      const obj: any = {}

      headers.forEach((header, index) => {
        obj[header.trim()] = data[index] ? data[index].trim() : null
      })

      result.push(obj)
    }

    return JSON.stringify(result)
  }
}
```

위와 같이 JSON 형태의 문자로 변경하여 응답해주는 어탭터를 만들어 사용할 수 있습니다.

```ts
const jsonMessage = new JsonMessage()
console.log(jsonMessage.requestJsonStr())
// [{"id":"2","name":"foo","age":"20"}]

const csvMessage = new CsvMessage()
const adapterMessage = new AdapterMessage(csvMessage)
console.log(adapterMessage.requestJsonStr())
// [{"id":"1","name":"boo","age":"10"}]
```

[⬆목차](#목차)

## 2. 브리지 패턴

브리지는 밀접하게 관련된 클래스들의 집합을 두개의 개별 계층 추상화와 구현으로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴입니다.

예를 들어, 구현 계층에 해당하는 TV, 라디오와 같은 장치들 그리고 추상화 계층에 해당하는 리모컨으로 나눕니다. 리모콘이 추상화 계층인 이유는 리모콘은 구체적인 기능을 제공하는 것이 아니라 장치와의 상호작용 방식만 정의하기 때문입니다. 여기에서 이제 장치를 추상화한 인터페이스를 정의하고 TV와 라디오, 그리고 리모컨 모두 이 추상화한 장치 인터페이스에 의존하여 개발하여 브리지 패턴의 핵심인 `구현과 추상의 분리`를 하여 장치와 리모컨을 독립적으로 개발하거나 확장에 용이하도록 합니다.

```ts
interface Device {
  setVolume(volume: number): void
  getVolume(): number
}
```

위와 같이 장치의 인터페이스를 정의하고

```ts
class TV implements Device {
  private volume: number

  constructor() {
    this.volume = 0
  }

  setVolume(volume: number): void {
    this.volume = volume
    console.log(`Volume is set to ${volume}`)
  }

  getVolume(): number {
    return this.volume
  }
}
```

위와 같이 Device를 구현한 TV라는 클래스를 정의할 수 있습니다.

```ts
class RemoteControl {
  protected device: Device

  constructor(device: Device) {
    this.device = device
  }
}
```

위와 같이 Device를 필드로 가지는 리모컨 클래스를 정의하고

```ts
class AdvancedRemoteControl extends RemoteControl {
  mute() {
    this.device.setVolume(0)
  }
}
```

위와 같이 리모컨 클래스를 확장하여 리모컨을 확장할 수 있습니다.

```ts
const tv = new TV()
const remote = new AdvancedRemoteControl(tv)
remote.mute()
// Volume is set to 0
```

위와 같이 장치를 추상화한 Device 인터페이스를 중심으로 다양한 장치와 리모컨을 확장할 수도 독립적으로 개발할 수도 있습니다.

[⬆목차](#목차)

## 3. 컴포지트 패턴

컴포지트 패턴은 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 디자인 패턴으로 개별 객체와 복합 객체를 동일하게 취급할 수 있어서 단일 객체와 복합 객체간의 상호 작용을 일관되게 처리할 수 있습니다.

예를 들어, 동물이라는 추상 클래스가 있고 이를 상속받는 개별 동물 클래스와 동물 그룹 클래스가 있고 또 이 동물 그룹들을 모은 그룹을 구성하였을때 이 개별 동물 클래스와 그룹 클래스가 같은 추상 클래스를 상속 받음으로서 일관된 처리를 할 수 있습니다.

```ts
abstract class Animal {
  abstract sound(): void
}
```

위와 같이 `Animal`이라는 추상 클래스와 `sound`라는 추상 메서드를 정의합니다.

```ts
class Dog extends Animal {
  sound() {
    console.log("woof")
  }
}

class Cat extends Animal {
  sound() {
    console.log("meow")
  }
}

class AnimalGroup extends Animal {
  animals: Animal[] = []

  add(animal: Animal) {
    this.animals.push(animal)
  }

  sound() {
    console.log("Animals group sounds")
    this.animals.forEach((animal) => {
      animal.sound()
    })
  }
}
```

`Animal`이라는 추상 클래스를 상속 받은 개별 클래스인 `Dog`, `Cat` 그리고 동물의 그룹을 갖는 복합 객체 `AnimalGroup`를 선언합니다.

```ts
const dogGroup = new AnimalGroup()
dogGroup.add(new Dog())
dogGroup.add(new Dog())

const catGroup = new AnimalGroup()
catGroup.add(new Cat())
catGroup.add(new Cat())

const zoo = new AnimalGroup()
zoo.add(dogGroup)
zoo.add(catGroup)
```

위와 같이 `dogGroup`에 `Dog`가 2마리, `catGroup`에 `Cat`이 2마리 그리고 이 두 그룹을 하나로 묶은 `zoo`라는 복합 객체를 만들었습니다. 이 모든 객체는 `Animal`을 구체 객체입니다.

```ts
zoo.sound()

// Animals group sounds
// Animals group sounds
// woof
// woof
// Animals group sounds
// meow
// meow
```

위와 같이 `zoo` 객체의 `sound` 메서드를 호출하면 트리 구조의 모든 객체의 `sound` 메서드가 일괄적으로 호출됩니다.

[⬆목차](#목차)

## 4. 데코레이터 패턴

데코레이터 패턴은 객체에 동적으로 새로운 기능을 추가할 수 있게 해주는 패턴으로, 상속을 사용하지 않고도 여러 개의 데코레이터를 조합해 기능을 확장할 수 있습니다. 간단한 예로 우리가 일상 생활에서 날씨에 따라 옷을 입는 것과 같습니다. 추울때 따듯한 스웨터를 감싸며 비가 오면 비옷을 입습니다. 또한 여러벌의 옷을 입으면 복합 효과를 얻을 수 있습니다.

아래는 여러 알림 클래스를 선택적으로 사용하는 예시입니다.

```ts
interface Notifier {
  send(message: string): void
}
```

위와 같이 알림기에 대한 인터페이스가 있습니다.

```ts
class EmailNotification implements Notifier {
  send(message: string) {
    console.log(`Email: ${message}`)
  }
}
```

기본적으로 알림은 이메일 알림을 제공합니다.

```ts
abstract class NotificationDecorator implements Notifier {
  constructor(private notifier: Notifier) {}

  send(message: string) {
    this.notifier.send(message)
  }
}
```

이제 추상 클래스로 알림에 대한 데코레이터를 만들어줍니다.

```ts
class SlackNotification extends NotificationDecorator {
  send(message: string) {
    super.send(message)
    console.log(`Slack: ${message}`)
  }
}

class SMSNotification extends NotificationDecorator {
  send(message: string) {
    super.send(message)
    console.log(`SMS: ${message}`)
  }
}
```

슬랙 알림과 SMS 알림에 대한 구현 클래스를 선언해주었습니다. super()를 통해서 부모의 send 메서드도 호출이 됩니다.

```ts
const emailNotification = new EmailNotification()
const slackNotification = new SlackNotification(emailNotification)
slackNotification.send("Hello, World!")
// Email: Hello, World!
// Slack: Hello, World!

const smsNotification = new SMSNotification(slackNotification)
smsNotification.send("Hello, World!")
// Email: Hello, World!
// Slack: Hello, World!
// SMS: Hello, World!
```

위와 같이 다양한 데코레이터 스택을 조합하여 사용할 수 있습니다.

[⬆목차](#목차)

## 5. 퍼사드 패턴

퍼사드 패턴은 복잡한 서브시스템들을 단순화된 인터페이스로 감싸, 클라이언트가 서브시스템의 세부 구현을 신경 쓰지 않고 쉽게 접근할 수 있도록 하는 구조적 패턴입니다.

아래는 간단한 컴퓨터 실행과 종료를 구현한 퍼사드 패턴 예시입니다.

```ts
class CPU {
  start(): void {
    console.log("CPU started")
  }

  shutdown(): void {
    console.log("CPU shutting down")
  }
}

class Memory {
  load(): void {
    console.log("Memory loading data")
  }

  clear(): void {
    console.log("Memory clearing data")
  }
}

class HardDrive {
  read(): void {
    console.log("HardDrive reading data")
  }

  write(): void {
    console.log("HardDrive writing data")
  }
}
```

컴퓨터를 구성하는 하위 시스템들을 정의합니다.

```ts
class ComputerFacade {
  private cpu: CPU
  private memory: Memory
  private hardDrive: HardDrive

  constructor() {
    this.cpu = new CPU()
    this.memory = new Memory()
    this.hardDrive = new HardDrive()
  }

  start(): void {
    console.log("Starting computer...")
    this.cpu.start()
    this.memory.load()
    this.hardDrive.read()
    console.log("Computer started")
  }

  shutdown(): void {
    console.log("Shutting down computer...")
    this.cpu.shutdown()
    this.memory.clear()
    this.hardDrive.write()
    console.log("Computer shut down")
  }
}
```

퍼사드 패턴을 적용한 컴퓨터 클래스를 정의해줍니다.

```ts
const computer = new ComputerFacade()
computer.start()
// Starting computer...
// CPU started
// Memory loading data
// HardDrive reading data
// Computer started
computer.shutdown()
// Shutting down computer...
// CPU shutting down
// Memory clearing data
// HardDrive writing data
// Computer shut down
```

`start`, `shutdown`과 같이 간단한 인터페이스로 서비스 동작을 구현할 수 있습니다.

[⬆목차](#목차)

## 6. 플라이웨이트 패턴

플라이웨이트 패턴은 많은 수의 객체를 효율적으로 관리하기 위해, 동일하거나 비슷한 객체를 공유하여 메모리 사용을 최소화하는 구조적 패턴입니다. 주로 불변 객체나 반복적으로 사용되는 객체에 적용됩니다. 클래스의 재사용 기준이 되는 값을 정하여 인스턴스를 계속 생성하지 않고 동일한 기준에서는 반복 사용하는 값을 메모이제이션 하듯이 인스턴스를 캐시하여 재사용합니다.

```ts
interface Shape {
  draw(): void
}

class Circle implements Shape {
  private color: string

  constructor(color: string) {
    this.color = color
  }

  draw(): void {
    console.log(`Circle: Draw() [Color : ${this.color}]`)
  }
}
```

위와 같이 색을 파라미터로 받아서 draw 메서드를 통해 원을 그리는 클래스가 있습니다.

```ts
class ShapeFactory {
  private static circleMap: Map<string, Circle> = new Map()

  static getCircle(color: string): Circle {
    let circle = this.circleMap.get(color)

    if (!circle) {
      circle = new Circle(color)
      this.circleMap.set(color, circle)
      console.log(`Creating circle of color : ${color}`)
    }
    return circle
  }
}
```

플라이웨이트 패턴으로 입력받은 색을 키로하는 Map을 필드로 가지고 있으며 입력받은 색이 Map에 없을때에만 인스턴스를 만들도록 합니다.

```ts
function main() {
  const colors = ["Red", "Green", "Blue", "White", "Black"]

  for (let i = 0; i < 20; ++i) {
    const circle = ShapeFactory.getCircle(
      colors[Math.floor(Math.random() * colors.length)]
    )
    circle.draw()
  }
}

main()
// Creating circle of color : Black
// Circle: Draw() [Color : Black]
// Creating circle of color : White
// ...
```

로그를 확인하면, colors의 개 수만큼만 인스턴스를 만들고 한번 만들어진 인스턴스를 재사용하는 것을 확인할 수 있습니다.

[⬆목차](#목차)

## 7. 프록시 패턴

프록시 패턴은 접근 제어, 지연 로딩, 로깅 등의 목적으로 실제 객체에 대한 대리 객체를 제공하여, 클라이언트가 실제 객체와 간접적으로 상호작용하게 하는 구조적 패턴입니다. 예를 들어 메인 기능을 가지고 있는 클래스를 필드로 가진 보안적인 검증을 하는 프록시 클래스를 사용하여 검증을 거친 후 선택적으로 메인 클래스를 사용하거나, 메인 클래스에 무거운 동작을 포함하고 있을 경우 프록시 클래스에서 간단한 기능들을 동작하게 하고 무거운 동작은 필요한 시점에 메인 클래스를 호출하여 사용하는 패턴입니다.

```ts
interface Subject {
  request(): void
}

class RealSubject implements Subject {
  request(): void {
    console.log("RealSubject: Handling request.")
  }
}
```

위와 같이 `RealSubject` 라는 클래스와 그 안에 `request` 메서드가 있을 때,

```ts
class SubjectProxy implements Subject {
  private realSubject: Subject

  constructor(realSubject: Subject) {
    this.realSubject = realSubject
  }

  request(): void {
    if (this.checkAccess()) {
      this.realSubject.request()
    }
  }

  private checkAccess(): boolean {
    console.log("Proxy: Checking access prior to firing a real request.")
    // 이곳에 접근에 대한 권한이나 조건에 대한 로직을 작성합니다.
    return true
  }
}
```

위와 같이 `RealSubject`를 필드로 하는 프록시 클래스를 선언하여 `request` 요청이 왔을때 권한이나 조건에 대한 검증 과정을 추가합니다.

```ts
const realSubject = new RealSubject()
const proxy = new SubjectProxy(realSubject)
proxy.request()
// Proxy: Checking access prior to firing a real request.
// RealSubject: Handling request.
```

이렇게 프록시 패턴을 사용하여 구현함으로써 접근 권한이나 조건에 대한 변화가 생겨도 메인 클래스의 수정 없이 프록시 클래스의 수정으로 효율적으로 관리할 수 있습니다.

[⬆목차](#목차)

# 생성 패턴

## 1. 팩토리 메서드 패턴

팩토리 메서드 패턴은 객체 생성을 위한 인터페이스를 정의하되, 실제 생성할 객체의 구체적인 클래스는 서브클래스에서 결정하도록 하는 생성 패턴입니다. 이를 통해 객체 생성 코드를 캡슐화하고 유연성을 높일 수 있습니다.

```ts
interface Product {
  operation(): string
}

class ConcreteProductA implements Product {
  public operation(): string {
    return "ConcreteProductA"
  }
}

class ConcreteProductB implements Product {
  public operation(): string {
    return "ConcreteProductB"
  }
}
```

실제 생성되는 구체적인 클래스를 정의합니다.

```ts
abstract class Creator {
  public abstract factoryMethod(): Product

  public someOperation(): string {
    const product = this.factoryMethod()
    return `Creator: The same creator's code has just worked with ${product.operation()}`
  }
}

class ConcreteCreatorA extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProductA()
  }
}

class ConcreteCreatorB extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProductB()
  }
}
```

팩토리 메서드 패턴을 사용하여 구체 클래스를 생성하는 팩토리 클래스를 정의합니다.

```ts
const creatorA = new ConcreteCreatorA()
console.log(creatorA.someOperation())
// Creator: The same creator's code has just worked with ConcreteProductA

const creatorB = new ConcreteCreatorB()
console.log(creatorB.someOperation())
// Creator: The same creator's code has just worked with ConcreteProductB
```

[⬆목차](#목차)

## 2. 추상 팩토리 패턴

추상 팩토리 패턴은 서로 관련된 객체들의 집합을 생성하기 위한 인터페이스를 제공하며, 구체적인 클래스는 지정하지 않고 다양한 객체군을 일관성 있게 생성할 수 있도록 하는 생성 패턴입니다.

아래의 버튼과 체크박스를 화면 모드(다크모드, 라이트모드)에 따라 다르게 객체군을 생성하는 예시 코드입니다.

```ts
interface Button {
  render(): void
}

interface Checkbox {
  render(): void
}

class LightButton implements Button {
  render(): void {
    console.log("Rendering a light mode button.")
  }
}

class LightCheckbox implements Checkbox {
  render(): void {
    console.log("Rendering a light mode checkbox.")
  }
}

class DarkButton implements Button {
  render(): void {
    console.log("Rendering a dark mode button.")
  }
}

class DarkCheckbox implements Checkbox {
  render(): void {
    console.log("Rendering a dark mode checkbox.")
  }
}
```

버튼과 체크박스의 인터페이스를 정의하고 라이트모드의 버튼과 체크박스, 그리고 다크모드의 버튼과 체크박스를 정의해주었습니다.

```ts
interface GUIFactory {
  createButton(): Button
  createCheckbox(): Checkbox
}

class LightModeFactory implements GUIFactory {
  createButton(): Button {
    return new LightButton()
  }

  createCheckbox(): Checkbox {
    return new LightCheckbox()
  }
}

class DarkModeFactory implements GUIFactory {
  createButton(): Button {
    return new DarkButton()
  }

  createCheckbox(): Checkbox {
    return new DarkCheckbox()
  }
}
```

GUIFactory 인터페이스와 라이트모드, 다크모드 팩토리를 정의해주었습니다.

```ts
let factory: GUIFactory
const mode = "dark" // 또는 "light"
if (mode === "light") {
  factory = new LightModeFactory()
} else {
  factory = new DarkModeFactory()
}

factory.createButton().render()
// Rendering a dark mode button.
factory.createCheckbox().render()
// Rendering a dark mode checkbox.
```

실제로는 이렇게 사용하지는 않겠지만 대략, 위와 같이 `factory`에 다양한 객체군을 일관성 있게 생성할 수 있습니다.

[⬆목차](#목차)

## 3. 빌더 패턴

빌더 패턴은 복잡한 객체를 단계적으로 생성할 수 있도록 돕는 생성 패턴으로, 객체 생성 과정을 분리하여 동일한 생성 절차에서 다양한 표현을 가능하게 합니다. 이를 통해 객체의 생성 과정과 표현 방식을 분리할 수 있습니다.

```ts
class Product {
  private name: string
  private price: number
  private description: string

  constructor(builder: ProductBuilder) {
    this.name = builder.name
    this.price = builder.price
    this.description = builder.description
  }

  getName(): string {
    return this.name
  }

  getPrice(): number {
    return this.price
  }

  getDescription(): string {
    return this.description
  }
}
```

위와 같이 제품에 대한 클래스가 있을 때

```ts
class ProductBuilder {
  name: string
  price: number
  description: string

  constructor(name: string) {
    this.name = name
  }

  setPrice(price: number): ProductBuilder {
    this.price = price
    return this
  }

  setDescription(description: string): ProductBuilder {
    this.description = description
    return this
  }

  build(): Product {
    return new Product(this)
  }
}
```

위와 같이 빌더 클래스를 정의하고, 각각 메서드를 통해 필드값을 채우고 최종적으로 빌드 메서드를 통해 제품 객체를 생성합니다.

```ts
const product = new ProductBuilder("Laptop")
  .setPrice(1500)
  .setDescription("A high-end gaming laptop")
  .build()

console.log(product.getName())
// Laptop
console.log(product.getPrice())
// 1500
console.log(product.getDescription())
// A high-end gaming laptop
```

[⬆목차](#목차)

## 4. 프로토타입 패턴

프로토타입 패턴은 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴으로, 객체를 새로 만들기보다 복사함으로써 성능을 최적화하거나 다양한 객체 생성 방식을 유연하게 처리할 수 있습니다.

```ts
interface Prototype {
  field: string
  clone(): Prototype
}

class ConcretePrototype implements Prototype {
  field: string

  constructor(field: string) {
    this.field = field
  }

  clone(): Prototype {
    return new ConcretePrototype(this.field)
  }
}

const original = new ConcretePrototype("Original")
const copy = original.clone()

console.log(original.field)
// Output: Original
console.log(copy.field)
// Output: Original
;(copy as ConcretePrototype).field = "Modified"

console.log(original.field)
// Output: Original
console.log(copy.field)
// Output: Modified
```

위 예시 코드는 아주 단순한 클래스 구성으로 성능적으로 큰 이점은 없지만, 만약 많은 필드값을 가지고 있거나 생성자에 복잡한 로직이 있을때, 또는 객체의 수가 많거나 동적으로 클래스가 결정될 때 clone()을 통한 객체 복제는 성능과 유연성 모두에서 이점을 제공합니다.

[⬆목차](#목차)

## 5. 싱글턴 패턴

싱글턴 패턴은 특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 생성 패턴입니다. 이 패턴은 전역적으로 접근 가능한 고정된 인스턴스를 제공하며, 모든 클라이언트가 동일한 인스턴스를 공유하도록 만듭니다. 이를 통해 공유 자원 관리(예: 데이터베이스 연결, 설정 파일 관리)나 애플리케이션의 상태 관리와 같은 상황에서 불필요한 객체 생성을 방지하고 자원의 낭비를 줄입니다.

```ts
class Singleton {
  private static instance: Singleton

  private constructor() {}

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton()
    }
    return Singleton.instance
  }

  public someMethod(): void {
    console.log("Singleton method called")
  }
}

const singleton1 = Singleton.getInstance()
const singleton2 = Singleton.getInstance()

console.log(singleton1 === singleton2)
// true

singleton1.someMethod()
// Singleton method called
```

싱글턴 패턴은 전역적으로 하나의 인스턴스를 사용하기 때문에, 테스트에서 객체의 상태를 독립적인 환경으로 만들기 어렵기 때문에 테스트 케이스를 작성하기에 어려울 수 있습니다. 예를 들면 싱글턴 내부에 상태를 갖고 있다면 다른 테스트 간에 그 상태가 공유될 수 있어, 기대하는 값을 얻지 못할 수 있습니다.

또한 싱글턴 패턴을 사용한 객체의 인스턴스는 전역으로 관리하기 때문에, 어떠한 클래스 내부에서 싱글턴 인스턴스를 사용한다면, 해당 클래스는 싱글턴 인스턴스를 직접적으로 참조하게 되고 해당 클래스에 강하게 결합되는 단점이 있습니다.

[⬆목차](#목차)
