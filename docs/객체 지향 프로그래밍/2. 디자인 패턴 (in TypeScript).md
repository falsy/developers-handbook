# 디자인 패턴 (in TypeScript)

## Reference

- [Refactoring.Guru](https://refactoring.guru/ko)(웹 사이트)
- [위키피디아](https://ko.wikipedia.org/)(웹 사이트)
- [얄팍한 코딩사전](https://www.youtube.com/@yalco-coding)(유튜브)
- [코드없는 프로그래밍](https://www.youtube.com/@코드없는프로그래밍)(유튜브)

## 목차

- 구조 패턴
  - [1. 어탭터 패턴](#1-어댑터-패턴)
  - [2. 브리지 패턴](#2-브리지-패턴)
  - [3. 컴포지트 패턴](#3-컴포지트-패턴)
  - [4. 데코레이터 패턴](#4-데코레이터-패턴)
  - [5. 퍼사드 패턴](#5-퍼사드-패턴)
  - [6. 플라이웨이트 패턴](#6-플라이웨이트-패턴)
  - [7. 프록시 패턴](#7-프록시-패턴)
- 생성 패턴
  - [1. 팩토리 메서드 패턴]
  - [2. 추상 팩토리 패턴]
  - [3. 빌더 패턴]
  - [4. 프로토타입 패턴]
  - [5. 싱글턴 패턴]
- 행동 패턴
  - [1. 책임 연쇄 패턴]
  - [2. 커맨드 패턴]
  - [3. 반복자 패턴]
  - [4. 중재자 패턴]
  - [5. 메멘토 패턴]
  - [6. 옵서버 패턴]
  - [7. 상태 패턴]
  - [8. 전략 패턴]
  - [9. 탬플릿 메서드 패턴]
  - [10. 비지터 패턴]

# 구조 패턴

## 1. 어댑터 패턴

호환되지 않는 객체들을 함께 사용할 수 있도록 해주는 패턴입니다. 어댑터라는 두 객체 사이의 래퍼(Wrapper) 역할을 하여 호환되지 않던 두 객체를 연결해줍니다. 특히 일부 레거시 코드를 기반으로 하는 서비스에 많이 사용됩니다.

예를 들어, 과거 CSV 형태의 값을 응답하는 객체가 있었고 현재는 JSON을 사용하여 프로그램을 구성하고 있을때, 이전 CSV 값을 응답하는 객체를, CSV 형태를 JSON 형태로 변경해주는 어뎁터 래퍼를 추가하여 현재의 프로그램에 호환될 수 있도록 하는 방법입니다.

```ts
class CsvMessage {
  requestCsvStr(): string {
    return `id,name,age\n1,boo,10`
  }
}
```

위와 같이 기존에 사용하던 CSV 형태의 데이터를 응답하는 객체가 있고

```ts
class JsonMessage {
  requestJsonStr(): string {
    return JSON.stringify([{ id: "2", name: "foo", age: "20" }])
  }
}
```

현재는 위와 같이 JSON 형태의 데이터 응답을 사용하고 있다면,

```ts
class AdapterMessage extends JsonMessage {
  private csvMessage: CsvMessage

  constructor(csvMessage: CsvMessage) {
    super()
    this.csvMessage = csvMessage
  }

  requestJsonStr(): string {
    const rows = this.csvMessage.requestCsvStr().split("\n")
    const headers = rows[0].split(",")
    const result = []

    for (let i = 1; i < rows.length; i++) {
      const row = rows[i].trim()
      if (!row) continue

      const data = row.split(",")
      const obj: any = {}

      headers.forEach((header, index) => {
        obj[header.trim()] = data[index] ? data[index].trim() : null
      })

      result.push(obj)
    }

    return JSON.stringify(result)
  }
}
```

위와 같이 JSON 형태의 문자로 변경하여 응답해주는 어탭터를 만들어 사용할 수 있습니다.

```ts
const jsonMessage = new JsonMessage()
console.log(jsonMessage.requestJsonStr())
// [{"id":"2","name":"foo","age":"20"}]

const csvMessage = new CsvMessage()
const adapterMessage = new AdapterMessage(csvMessage)
console.log(adapterMessage.requestJsonStr())
// [{"id":"1","name":"boo","age":"10"}]
```

[⬆목차](#목차)

## 2. 브리지 패턴

브리지는 밀접하게 관련된 클래스들의 집합을 두개의 개별 계층 추상화와 구현으로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴입니다.

예를 들어, 구현 계층에 해당하는 TV, 라디오와 같은 장치들 그리고 추상화 계층에 해당하는 리모컨으로 나눕니다. 리모콘이 추상화 계층인 이유는 리모콘은 구체적인 기능을 제공하는 것이 아니라 장치와의 상호작용 방식만 정의하기 때문입니다. 여기에서 이제 장치를 추상화한 인터페이스를 정의하고 TV와 라디오, 그리고 리모컨 모두 이 추상화한 장치 인터페이스에 의존하여 개발하여 브리지 패턴의 핵심인 `구현과 추상의 분리`를 하여 장치와 리모컨을 독립적으로 개발하거나 확장에 용이하도록 합니다.

```ts
interface Device {
  setVolume(volume: number): void
  getVolume(): number
}
```

위와 같이 장치의 인터페이스를 정의하고

```ts
class TV implements Device {
  private volume: number

  constructor() {
    this.volume = 0
  }

  setVolume(volume: number): void {
    this.volume = volume
    console.log(`Volume is set to ${volume}`)
  }

  getVolume(): number {
    return this.volume
  }
}
```

위와 같이 Device를 구현한 TV라는 클래스를 정의할 수 있습니다.

```ts
class RemoteControl {
  protected device: Device

  constructor(device: Device) {
    this.device = device
  }
}
```

위와 같이 Device를 필드로 가지는 리모컨 클래스를 정의하고

```ts
class AdvancedRemoteControl extends RemoteControl {
  mute() {
    this.device.setVolume(0)
  }
}
```

위와 같이 리모컨 클래스를 확장하여 리모컨을 확장할 수 있습니다.

```ts
const tv = new TV()
const remote = new AdvancedRemoteControl(tv)
remote.mute()
// Volume is set to 0
```

위와 같이 장치를 추상화한 Device 인터페이스를 중심으로 다양한 장치와 리모컨을 확장할 수도 독립적으로 개발할 수도 있습니다.

[⬆목차](#목차)

## 3. 컴포지트 패턴

컴포지트 패턴은 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 디자인 패턴으로 개별 객체와 복합 객체를 동일하게 취급할 수 있어서 단일 객체와 복합 객체간의 상호 작용을 일관되게 처리할 수 있습니다.

예를 들어, 동물이라는 추상 클래스가 있고 이를 상속받는 개별 동물 클래스와 동물 그룹 클래스가 있고 또 이 동물 그룹들을 모은 그룹을 구성하였을때 이 개별 동물 클래스와 그룹 클래스가 같은 추상 클래스를 상속 받음으로서 일관된 처리를 할 수 있습니다.

```ts
abstract class Animal {
  abstract sound(): void
}
```

위와 같이 `Animal`이라는 추상 클래스와 `sound`라는 추상 메서드를 정의합니다.

```ts
class Dog extends Animal {
  sound() {
    console.log("woof")
  }
}

class Cat extends Animal {
  sound() {
    console.log("meow")
  }
}

class AnimalGroup extends Animal {
  animals: Animal[] = []

  add(animal: Animal) {
    this.animals.push(animal)
  }

  sound() {
    console.log("Animals group sounds")
    this.animals.forEach((animal) => {
      animal.sound()
    })
  }
}
```

`Animal`이라는 추상 클래스를 상속 받은 개별 클래스인 `Dog`, `Cat` 그리고 동물의 그룹을 갖는 복합 객체 `AnimalGroup`를 선언합니다.

```ts
const dogGroup = new AnimalGroup()
dogGroup.add(new Dog())
dogGroup.add(new Dog())

const catGroup = new AnimalGroup()
catGroup.add(new Cat())
catGroup.add(new Cat())

const zoo = new AnimalGroup()
zoo.add(dogGroup)
zoo.add(catGroup)
```

위와 같이 `dogGroup`에 `Dog`가 2마리, `catGroup`에 `Cat`이 2마리 그리고 이 두 그룹을 하나로 묶은 `zoo`라는 복합 객체를 만들었습니다. 이 모든 객체는 `Animal`을 구체 객체입니다.

```ts
zoo.sound()

// Animals group sounds
// Animals group sounds
// woof
// woof
// Animals group sounds
// meow
// meow
```

위와 같이 `zoo` 객체의 `sound` 메서드를 호출하면 트리 구조의 모든 객체의 `sound` 메서드가 일괄적으로 호출됩니다.

[⬆목차](#목차)

## 4. 데코레이터 패턴

데코레이터 패턴은 객체에 동적으로 새로운 기능을 추가할 수 있게 해주는 패턴으로, 상속을 사용하지 않고도 여러 개의 데코레이터를 조합해 기능을 확장할 수 있습니다. 간단한 예로 우리가 일상 생활에서 날씨에 따라 옷을 입는 것과 같습니다. 추울때 따듯한 스웨터를 감싸며 비가 오면 비옷을 입습니다. 또한 여러벌의 옷을 입으면 복합 효과를 얻을 수 있습니다.

아래는 여러 알림 클래스를 선택적으로 사용하는 예시입니다.

```ts
interface Notifier {
  send(message: string): void
}
```

위와 같이 알림기에 대한 인터페이스가 있습니다.

```ts
class EmailNotification implements Notifier {
  send(message: string) {
    console.log(`Email: ${message}`)
  }
}
```

기본적으로 알림은 이메일 알림을 제공합니다.

```ts
abstract class NotificationDecorator implements Notifier {
  constructor(private notifier: Notifier) {}

  send(message: string) {
    this.notifier.send(message)
  }
}
```

이제 추상 클래스로 알림에 대한 데코레이터를 만들어줍니다.

```ts
class SlackNotification extends NotificationDecorator {
  send(message: string) {
    super.send(message)
    console.log(`Slack: ${message}`)
  }
}

class SMSNotification extends NotificationDecorator {
  send(message: string) {
    super.send(message)
    console.log(`SMS: ${message}`)
  }
}
```

슬랙 알림과 SMS 알림에 대한 구현 클래스를 선언해주었습니다. super()를 통해서 부모의 send 메서드도 호출이 됩니다.

```ts
const emailNotification = new EmailNotification()
const slackNotification = new SlackNotification(emailNotification)
slackNotification.send("Hello, World!")
// Email: Hello, World!
// Slack: Hello, World!

const smsNotification = new SMSNotification(slackNotification)
smsNotification.send("Hello, World!")
// Email: Hello, World!
// Slack: Hello, World!
// SMS: Hello, World!
```

위와 같이 다양한 데코레이터 스택을 조합하여 사용할 수 있습니다.

[⬆목차](#목차)

## 5. 퍼사드 패턴

퍼사드 패턴은 복잡한 서브시스템들을 단순화된 인터페이스로 감싸, 클라이언트가 서브시스템의 세부 구현을 신경 쓰지 않고 쉽게 접근할 수 있도록 하는 구조적 패턴입니다.

아래는 간단한 컴퓨터 실행과 종료를 구현한 퍼사드 패턴 예시입니다.

```ts
class CPU {
  start(): void {
    console.log("CPU started")
  }

  shutdown(): void {
    console.log("CPU shutting down")
  }
}

class Memory {
  load(): void {
    console.log("Memory loading data")
  }

  clear(): void {
    console.log("Memory clearing data")
  }
}

class HardDrive {
  read(): void {
    console.log("HardDrive reading data")
  }

  write(): void {
    console.log("HardDrive writing data")
  }
}
```

컴퓨터를 구성하는 하위 시스템들을 정의합니다.

```ts
class ComputerFacade {
  private cpu: CPU
  private memory: Memory
  private hardDrive: HardDrive

  constructor() {
    this.cpu = new CPU()
    this.memory = new Memory()
    this.hardDrive = new HardDrive()
  }

  start(): void {
    console.log("Starting computer...")
    this.cpu.start()
    this.memory.load()
    this.hardDrive.read()
    console.log("Computer started")
  }

  shutdown(): void {
    console.log("Shutting down computer...")
    this.cpu.shutdown()
    this.memory.clear()
    this.hardDrive.write()
    console.log("Computer shut down")
  }
}
```

퍼사드 패턴을 적용한 컴퓨터 클래스를 정의해줍니다.

```ts
const computer = new ComputerFacade()
computer.start()
// Starting computer...
// CPU started
// Memory loading data
// HardDrive reading data
// Computer started
computer.shutdown()
// Shutting down computer...
// CPU shutting down
// Memory clearing data
// HardDrive writing data
// Computer shut down
```

`start`, `shutdown`과 같이 간단한 인터페이스로 서비스 동작을 구현할 수 있습니다.

[⬆목차](#목차)

## 6. 플라이웨이트 패턴

플라이웨이트 패턴은 많은 수의 객체를 효율적으로 관리하기 위해, 동일하거나 비슷한 객체를 공유하여 메모리 사용을 최소화하는 구조적 패턴입니다. 주로 불변 객체나 반복적으로 사용되는 객체에 적용됩니다. 클래스의 재사용 기준이 되는 값을 정하여 인스턴스를 계속 생성하지 않고 동일한 기준에서는 반복 사용하는 값을 메모이제이션 하듯이 인스턴스를 캐시하여 재사용합니다.

```ts
interface Shape {
  draw(): void
}

class Circle implements Shape {
  private color: string

  constructor(color: string) {
    this.color = color
  }

  draw(): void {
    console.log(`Circle: Draw() [Color : ${this.color}]`)
  }
}
```

위와 같이 색을 파라미터로 받아서 draw 메서드를 통해 원을 그리는 클래스가 있습니다.

```ts
class ShapeFactory {
  private static circleMap: Map<string, Circle> = new Map()

  static getCircle(color: string): Circle {
    let circle = this.circleMap.get(color)

    if (!circle) {
      circle = new Circle(color)
      this.circleMap.set(color, circle)
      console.log(`Creating circle of color : ${color}`)
    }
    return circle
  }
}
```

플라이웨이트 패턴으로 입력받은 색을 키로하는 Map을 필드로 가지고 있으며 입력받은 색이 Map에 없을때에만 인스턴스를 만들도록 합니다.

```ts
function main() {
  const colors = ["Red", "Green", "Blue", "White", "Black"]

  for (let i = 0; i < 20; ++i) {
    const circle = ShapeFactory.getCircle(
      colors[Math.floor(Math.random() * colors.length)]
    )
    circle.draw()
  }
}

main()
// Creating circle of color : Black
// Circle: Draw() [Color : Black]
// Creating circle of color : White
// ...
```

로그를 확인하면, colors의 개 수만큼만 인스턴스를 만들고 한번 만들어진 인스턴스를 재사용하는 것을 확인할 수 있습니다.

[⬆목차](#목차)

## 7. 프록시 패턴

프록시 패턴은 접근 제어, 지연 로딩, 로깅 등의 목적으로 실제 객체에 대한 대리 객체를 제공하여, 클라이언트가 실제 객체와 간접적으로 상호작용하게 하는 구조적 패턴입니다. 예를 들어 메인 기능을 가지고 있는 클래스를 필드로 가진 보안적인 검증을 하는 프록시 클래스를 사용하여 검증을 거친 후 선택적으로 메인 클래스를 사용하거나, 메인 클래스에 무거운 동작을 포함하고 있을 경우 프록시 클래스에서 간단한 기능들을 동작하게 하고 무거운 동작은 필요한 시점에 메인 클래스를 호출하여 사용하는 패턴입니다.

```ts
interface Subject {
  request(): void
}

class RealSubject implements Subject {
  request(): void {
    console.log("RealSubject: Handling request.")
  }
}
```

위와 같이 `RealSubject` 라는 클래스와 그 안에 `request` 메서드가 있을 때,

```ts
class SubjectProxy implements Subject {
  private realSubject: Subject

  constructor(realSubject: Subject) {
    this.realSubject = realSubject
  }

  request(): void {
    if (this.checkAccess()) {
      this.realSubject.request()
    }
  }

  private checkAccess(): boolean {
    console.log("Proxy: Checking access prior to firing a real request.")
    // 이곳에 접근에 대한 권한이나 조건에 대한 로직을 작성합니다.
    return true
  }
}
```

위와 같이 `RealSubject`를 필드로 하는 프록시 클래스를 선언하여 `request` 요청이 왔을때 권한이나 조건에 대한 검증 과정을 추가합니다.

```ts
const realSubject = new RealSubject()
const proxy = new SubjectProxy(realSubject)
proxy.request()
// Proxy: Checking access prior to firing a real request.
// RealSubject: Handling request.
```

이렇게 프록시 패턴을 사용하여 구현함으로써 접근 권한이나 조건에 대한 변화가 생겨도 메인 클래스의 수정 없이 프록시 클래스의 수정으로 효율적으로 관리할 수 있습니다.
